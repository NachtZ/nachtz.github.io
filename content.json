[{"title":"将DPDK移植到snort上的DAQ","date":"2016-08-06T10:16:34.000Z","path":"2016/08/06/dpdk_daq/","text":"DAQ 与Snort在snort-daq中，daq的控制流程是这样的。如上所述，Snort在初始化的时候载入了daq。这个时候snort的所调用的api是daq_load_modules。也就是说，这个时候在主线程没有启动网卡，初始化实例的操作。在初始化整个snort之后（载入配置，载入daq及其他各个模块等等）。snort就进入了分析的阶段了。这个阶段的主角是pig，或者说更本质的，是pig下的analyzer。Snort下面开n个pig线程。pig线程下面调用analyzer来进行包解析。包解析的过程中是在pig线程中多线程并行进行的。每一个analyzer下面都初始化一个daq instance并调用acquire进行抓包并分析。每一个daq instance下面都有一个或多个网卡来获取数据。因为目的主要是介绍daq，所以怎么解析就不提了。从上图和上面的介绍就可以看得出来，一个snort下面有多个daq instance并行运行。每一个daq instance都会进行初始化操作，占用系统资源，获取网卡，抓包，调用callback，之间相互独立。并且是单线程的。 DAQ与DPDK如上面所介绍的。DAQ在设计的时候是单线程的。在本身的实现的几个模块中（Netmap,pcap等等）完全没有涉及到多线程的事情。在snort中的调用也是单线程并行调用的，相互之间各不影响。而Inter的DPDK在多线程方面则有限制。它所初始化的EAL层只能初始化一次。一个程序中只能运行一个dpdk主程序。所以就没有办法在snort中使用多线程。因为如果在snort中使用了多线程。那么实际上每个线程都会去尝试初始化dpdk的EAL。那么就会出错，导致最后只有一个线程能够成功初始化并启动。所以如果要想实现一个支持snort多线程的daq。就需要修改daq中api的逻辑。在实现中，利用线程id来绑定网卡。在daq的content中加入了一个nic-threadid的映射表。然后每个网卡都有一个独立的instance存储原本在daq_content中的信息。然后在线程调用daq相关函数的时候，都会先利用threadid来进行检索这个instance进行操作。通过这个方法就能够将dpdk中的各个网卡独立运行。 Github地址daq_dpdk基于的是dpdk16.04, daq2.1.0,snort 3.0 a04.使用方法在项目主页中。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"},{"name":"Snort","slug":"Snort","permalink":"https://nachtz.github.io/tags/Snort/"}]},{"title":"dpdk_ring剥离（单线程版）","date":"2016-06-17T10:19:59.000Z","path":"2016/06/17/dpdk_ring/","text":"DPDK_RING 剥离(sc)dpdk中的ring结构的原理在官方的doc中有。详细的介绍了单线程和多线程下的ring的结构的实现。其中线程安全的ring的出入队中没有用到锁，这个结构是比较巧妙的。此外，和一般的ring设计相比，dpdk的ring中减少了比较的次数和减法的次数。考虑了很多性能方面的东西。目前就剥离了单线程版的。代码如下： daq_ring.h12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef DAQ_RING_H#define DAQ_RING_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//#include &lt;pthread.h&gt;typedef struct _daq_ring&#123; // pthread_mutex_t mutex; int size; int mask; int cons_head; int cons_tail; int prod_head; int prod_tail; void * ring[0];&#125;;typedef struct _daq_ring daq_ring;//create a ring which can contain size's objects.daq_ring * daq_ring_create(int num);//fre a ring.int daq_ring_free(daq_ring * r);//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r);//see whether a ring is full.int daq_ring_isFull(daq_ring * r);//see the number of objects in ring now.int daq_ring_count(daq_ring * r);//see the size of a ring.int daq_ring_getSize(daq_ring *r);//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r);//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc);//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc);#endif//end of daq_ring.h -daq_ring.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include \"daq_ring.h\"/*typedef struct _daq_ring&#123; pthread_mutex_t mutex; unsigned int size; void * head; void * tail; void * memhead;&#125;daq_ring;*/daq_ring * daq_ring_create(int num)&#123; daq_ring * r = NULL; if(num &lt;=0)return NULL; r = (daq_ring *)malloc(sizeof(daq_ring) + num*sizeof(void*)); if(r == NULL)&#123; return NULL; &#125; r-&gt;size = num; r-&gt;mask = num-1; r-&gt;prod_head = r-&gt;prod_tail = r-&gt;cons_head = r-&gt;cons_tail = 0; // pthread_mutex_init(&amp;r-&gt;mutex,NULL); return r;&#125;//fre a ring.int daq_ring_free(daq_ring * r)&#123; free(r);&#125;//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r)&#123; return r-&gt;cons_tail == r-&gt;prod_tail;&#125;//see whether a ring is full.int daq_ring_isFull(daq_ring * r)&#123; return (((r-&gt;cons_tail - r-&gt;prod_tail -1)&amp;r-&gt;mask)==0);&#125;//see the number of objects in ring now.int daq_ring_count(daq_ring * r)&#123; return ((r-&gt;prod_tail - r-&gt;cons_tail)&amp;r-&gt;mask);&#125;//see the size of a ring.int daq_ring_getSize(daq_ring *r)&#123; return r-&gt;size;&#125;//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r)&#123; return ((r-&gt;cons_tail - r-&gt;prod_tail - 1) &amp; r-&gt;mask);&#125;//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc)&#123; int prod_head = r-&gt;prod_head; int cons_tail = r-&gt;cons_tail; int prod_next = prod_head +1; int mask = r-&gt;mask; int i ; int free = mask + cons_tail -prod_head; if(num &gt;free)&#123; if(free == 0)return 0; num = free; &#125; prod_next = prod_head +num; r-&gt;prod_head = prod_next; &#123; const int size = r-&gt;size; int idx = prod_head &amp; mask; if(idx + num &lt; size)&#123; for (i = 0; i &lt; (num &amp; ((~(unsigned)0x3))); i+=4, idx+=4) &#123; r-&gt;ring[idx] = obj_table[i]; r-&gt;ring[idx+1] = obj_table[i+1]; r-&gt;ring[idx+2] = obj_table[i+2]; r-&gt;ring[idx+3] = obj_table[i+3]; &#125; switch (num &amp; 0x3) &#123; case 3: r-&gt;ring[idx++] = obj_table[i++]; case 2: r-&gt;ring[idx++] = obj_table[i++]; case 1: r-&gt;ring[idx++] = obj_table[i++]; &#125; &#125;else&#123; for (i =0;idx&lt;size;++i,++idx) r-&gt;ring[idx] = obj_table[i]; for(idx = 0;i&lt;num;++i,++idx) r-&gt;ring[idx] = obj_table[i]; &#125; &#125; r-&gt;prod_tail = prod_next; return num;&#125;//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc)&#123; int cons_head,prod_tail; int cons_next,entries; int i; int mask = r-&gt;mask; cons_head = r-&gt;cons_head; prod_tail = r-&gt;prod_tail; entries = prod_tail - cons_head; if(num &gt; entries)&#123; if(entries == 0)return 0; num = entries; &#125; cons_next = cons_head + num; r -&gt; cons_head = cons_next; &#123; int idx = cons_head &amp; mask; int size = r-&gt; size; if (idx + num &lt; size) &#123; for (i = 0; i &lt; (num &amp; (~(unsigned)0x3)); i+=4, idx+=4) &#123; obj_table[i] = r-&gt;ring[idx]; obj_table[i+1] = r-&gt;ring[idx+1]; obj_table[i+2] = r-&gt;ring[idx+2]; obj_table[i+3] = r-&gt;ring[idx+3]; &#125; switch (num &amp; 0x3) &#123; case 3: obj_table[i++] = r-&gt;ring[idx++]; case 2: obj_table[i++] = r-&gt;ring[idx++]; case 1: obj_table[i++] = r-&gt;ring[idx++]; &#125; &#125; else &#123; for (i = 0; idx &lt; size; i++, idx++) obj_table[i] = r-&gt;ring[idx]; for (idx = 0; i &lt; num; i++, idx++) obj_table[i] = r-&gt;ring[idx]; &#125; &#125; r-&gt;cons_tail = cons_next; return num;&#125;void daq_ring_stat(daq_ring * r)&#123; printf(\"***********************************************\\n\"); printf(\"Daq_ring's size is %d\\n\",daq_ring_getSize(r)); printf(\"Daq_ring's objects now is %d.\\n\",daq_ring_count(r)); printf(\"Daq_ring's free space is %d\\n\",daq_ring_freeCount(r)); printf(\"Daq_ring is %s now.\\n\",daq_ring_isEmpty(r)?\"empty\":\"not empty\"); printf(\"Daq_ring is %s now.\\n\",daq_ring_isFull(r)?\"full\":\"not full\"); printf(\"***********************************************\\n\");&#125;void print_ptr(daq_ring *r)&#123; printf(\"r-&gt;cons:%p %p\\n\", r-&gt;cons_head, r-&gt;cons_tail); printf(\"r-&gt;prod:%p %p\\n\",r-&gt;prod_head,r-&gt;prod_tail); printf(\"r-&gt;ring[0]:%p\\n\",&amp;r-&gt;ring[0]); &#125;int test1()&#123; char * str[] = &#123; \"t1\",\"t2\",\"t3\",\"t4\",\"t5\",\"t6\",\"t7\",\"t8\",\"t9\",\"t10\",\"t11\",\"t12\",\"t13\" &#125;; void * ctx[12]; int i; for(i =0;i&lt;10;++i) printf(\"%s\\n\",str[i]); daq_ring * r = daq_ring_create(9); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(int i =0;i&lt;8;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r);print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(i =0;i&lt;10;++i) printf(\"%s\\n\",(char *)ctx[i]); return 0;&#125;int test2()&#123; int i; char * str[] = &#123; \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\", \"t10\", \"t11\", \"t12\", \"t13\", \"t14\", \"t15\", \"t16\", \"t17\" &#125;; void * ctx[18]; daq_ring * r = daq_ring_create(16); daq_ring_enqueue(r,str,14,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,4,1); for(i =0;i&lt;4;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,&amp;str[5],5,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,15,1); for(i =0;i&lt;15;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r);&#125;int main()&#123; test2(); return 0;&#125;","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]},{"title":"DPDK杂记","date":"2016-06-17T10:19:02.000Z","path":"2016/06/17/dpdk_note/","text":"###DPDK编译动态库将common_linuxapp中的CONFIG_RTE_BUILD_SHARED_LIB和CONFIG_RTE_BUILD_COMBINE_LIBS都改为y，重新编译。将生成的lib文件拷贝到linux的lib中。（在dpdk16.04中，combine这个选项被取消了。邮件组中提到说是默认就是combine了。但是实际编译中发现不同的网卡驱动还是没有编译在一起。拷贝的时候都需要拷贝过去。）之后就是修改Makefile.将makefile中的1include $(RTE_SDK)/mk/rteextapp.mk 改为1include $(RTE_SDK)/mk/rte.extshared.mk 把binary name中的app改为1SHARED = yourname.so 最后再加上库：1LDLIBS += -L/home/nachtz/dpdk-2.2.0/x86_64-native-linuxapp-gcc/lib -ldpdk -lrt -lm -lgcc_s -ldl 就行了。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]}]