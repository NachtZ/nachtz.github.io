[{"title":"在OpenDayLight控制器上开发Bundle","date":"2017-01-08T05:24:31.000Z","path":"2017/01/08/SDN_opendaylight_dev_bundle/","text":"在OpenDayLight控制器上开发Bundle odl远端仓库把startup project删除了。这个教程已经不再适用了。基于OpendayLight官网上的这篇文档翻译修改而来：Developing Apps on the OpenDaylight controller 本文档适用于boron版本。其他版本不一定适用。 综述本文档旨在指导如何在ODL控制器上开发应用。本文档包含以下内容： 创建一个简单的示例程序Hello World； 启动ODL控制器； 在Hello World测试简单的Remote Procedure Call(RPC)。 基础环境本文档需要以下基础开发环境： Maven 3.1.1 或更新的版本 JDK 7/8 合适的Maven settings.xml。可以通过一下途径获得默认的OpenDaylight settings.xml 1cp -n ~/.m2/settings.xml&#123;,.orig&#125; ; \\wget -q -O - https://raw.githubusercontent.com/opendaylight/odlparent/stable/boron/settings.xml &gt; ~/.m2/settings.xml 在除Linux和Mac OS X以外的环境中，你需要修改上诉命令中maven的本地仓库地址~/.m2/repository 构建一个Example模块 按以下步骤构建： 从Maven远端仓库中拉取一个初始工程。（第一次拉取的时候需要一定的时间） 123mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype \\-DarchetypeRepository=https://nexus.opendaylight.org/content/repositories/public/ \\-DarchetypeCatalog=https://nexus.opendaylight.org/content/repositories/public/archetype-catalog.xml 在国内，由于墙的缘故，你可能需要设置代理才能较快的下载工程。设置代理的参数如下： 1-DsocksProxyHost=YourProxyHost -DsocksProxyPort=YourProxyPort 此外你还可以使用多线程编译，跳过生成文档，跳过测试来加快速度： 1-T 1C -D maven.javadoc.skip=true -DskipTests 使用如下值来初始化工程： 123456Define value for property 'groupId': : org.opendaylight.exampleDefine value for property 'artifactId': : exampleDefine value for property 'version': 1.0-SNAPSHOT: : 1.0.0-SNAPSHOTDefine value for property 'package': org.opendaylight.example: :Define value for property 'classPrefix': : $&#123;artifactId.substring(0,1).toUpperCase()&#125;$&#123;artifactId.substring(1)&#125;Define value for property 'copyright': : Copyright (c) 2015 Yoyodyne, Inc. 其中，version,package,classPrefix都会默认填写，直接回车就行。 完成步骤1,2后，可以看到一个example文件夹。可以看到如下目录结构。 123456789$&#123;artifactId&#125;/example/cd example/api/artifacts/features/impl/karaf/pom.xml 构建示例工程。 注意，这个可能需要耗费一定的时间，你可以使用1中提到的maven参数来提升编译速度。 1mvn clean install 启动ODL控制器。 123cd karaf/target/assembly/binls./karaf 等待直至启动完毕出现以下命令行。可能需要等一段时间，这个时间和你电脑配置有关。 1opendaylight-user@root&gt; 查看日志，确认example模块被正常加载。 1log:display | grep Example 关闭ODL控制器。 1shutdown -f 定义一个简单的`Hello World RPC 从maven远端仓库拉取初始工程。 123mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype \\ -DarchetypeRepository=http://nexus.opendaylight.org/content/repositories/opendaylight.release/ \\ -DarchetypeCatalog=http://nexus.opendaylight.org/content/repositories/opendaylight.release/archetype-catalog.xml 这里需要注意，原文中使用的是snapshot，而使用snapshot会出现无法编译通过的问题。本文中使用release版本且目前的maven远端仓库release版本是boron。 使用如下值来初始化工程： 123456Define value for property 'groupId': : org.opendaylight.helloDefine value for property 'artifactId': : helloDefine value for property 'version': 1.0-SNAPSHOT: : 1.0.0-SNAPSHOTDefine value for property 'package': org.opendaylight.hello: :Define value for property 'classPrefix': : $&#123;artifactId.substring(0,1).toUpperCase()&#125;$&#123;artifactId.substring(1)&#125;Define value for property 'copyright': : Copyright (c) 2015 Yoyodyne, Inc. 其中，version,package,classPrefix都会默认填写，直接回车就行。 查看hello工程。 12345678cd hello/ls -1apiartifactsfeaturesimplkarafpom.xml 构建Hello工程。 1mvn clean install 同样，可以利用之前提到的参数来提升编译构建速度。 启动ODL控制器。 123cd karaf/target/assembly/binls./karaf 等待直至启动完毕出现以下命令行。可能需要等一段时间，这个时间和你电脑配置有关。 1opendaylight-user@root&gt; 查看日志，确认Hello模块被正常加载。 1log:display | grep Hello 关闭ODL控制器。 1shutdown -f 返回到Hello目录： 1cd ../../../../ 可以通过查看Hello模块的实现来了解7中的日志从何而来，模块实现源文件路径如下： 1impl/src/main/java/org/opendaylight/hello/impl/HelloProvider.java 可以使用HelloProvider.onSessionInitiate方法来添加自己的实现。 1234@Overridepublic void onSessionInitiated(ProviderContext session) &#123; LOG.info(\"HelloProvider Session Initiated\");&#125; 添加一个简单的HelloWorld RPC API 修改YANG文件。 1vi api/src/main/yang/hello.yang 修改为如下文件，通过修改该文件来定义hello-world RPC： 1234567891011121314151617181920 module hello &#123; yang-version 1; namespace \"urn:opendaylight:params:xml:ns:yang:hello\"; prefix \"hello\"; revision \"2015-01-05\" &#123; description \"Initial revision of hello model\"; &#125; rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greating &#123; type string; &#125; &#125; &#125;&#125; 返回到hello/api目录并构建你的API: 12cd ../../../mvn clean install 实现HelloWorld RPC API 定义HelloService，该服务会被HelloWorldAPI调用。 1cd ../impl/src/main/java/org/opendaylight/hello/impl/ 创建HelloWorldImpl.java文件，添加如下代码： 1234567891011121314151617181920212223/** Copyright © 2016 Cisco Systems and others. All rights reserved.** This program and the accompanying materials are made available under the* terms of the Eclipse Public License v1.0 which accompanies this distribution,* and is available at http://www.eclipse.org/legal/epl-v10.html*/package org.opendaylight.hello.impl;import java.util.concurrent.Future;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloService;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloWorldInput;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloWorldOutput;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloWorldOutputBuilder;import org.opendaylight.yangtools.yang.common.RpcResult;import org.opendaylight.yangtools.yang.common.RpcResultBuilder;public class HelloWorldImpl implements HelloService &#123; @Override public Future&lt;RpcResult&lt;HelloWorldOutput&gt;&gt; helloWorld(HelloWorldInput input) &#123; HelloWorldOutputBuilder helloBuilder = new HelloWorldOutputBuilder(); helloBuilder.setGreating(\"Hello \" + input.getName()); return RpcResultBuilder.success(helloBuilder.build()).buildFuture(); &#125;&#125; 修改HelloProvider.java.注册在hello.yang中创建的RPC. 你可以自己添加自己想要的实现，或者直接按如下编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Copyright © 2016 Cisco Systems and others. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v1.0 which accompanies this distribution, * and is available at http://www.eclipse.org/legal/epl-v10.html */package org.opendaylight.hello.impl;import org.opendaylight.controller.md.sal.binding.api.DataBroker;import org.opendaylight.controller.sal.binding.api.RpcProviderRegistry;import org.opendaylight.controller.sal.binding.api.BindingAwareBroker.RpcRegistration;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloProvider &#123; private static final Logger LOG = LoggerFactory.getLogger(HelloProvider.class); private final DataBroker dataBroker; private final RpcProviderRegistry rpcProviderRegistry; private RpcRegistration&lt;HelloService&gt; serviceRegistration; public HelloProvider(final DataBroker dataBroker, RpcProviderRegistry rpcProviderRegistry) &#123; this.dataBroker = dataBroker; this.rpcProviderRegistry = rpcProviderRegistry; &#125; /** * Method called when the blueprint container is created. */ public void init() &#123; serviceRegistration = rpcProviderRegistry.addRpcImplementation(HelloService.class, new HelloWorldImpl()); LOG.info(\"HelloProvider Session Initiated\"); &#125; /** * Method called when the blueprint container is destroyed. */ public void close() &#123; serviceRegistration.close(); LOG.info(\"HelloProvider Closed\"); &#125;&#125; &gt; 这边需要注意：文件开头的版权声明不能去掉，否则无法通过Maven构建。此外，官网上的源文件有问题。本文档的源文件至少通过了本地编译。 此外，需要在BluePrint中注册你的RPC API.修改如下： 12cd hello/impl/src/main/resources/org/opendaylight/blueprintvi impl-blueprint.xml 修改为如下。 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- vi: set et smarttab sw=4 tabstop=4: --&gt;&lt;!--Copyright © 2016 Cisco Systems and others. All rights reserved.This program and the accompanying materials are made available under theterms of the Eclipse Public License v1.0 which accompanies this distribution,and is available at http://www.eclipse.org/legal/epl-v10.html--&gt;&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"xmlns:odl=\"http://opendaylight.org/xmlns/blueprint/v1.0.0\"odl:use-default-for-reference-types=\"true\"&gt; &lt;reference id=\"dataBroker\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\" odl:type=\"default\" /&gt;&lt;reference id=\"rpcRegistry\" interface=\"org.opendaylight.controller.sal.binding.api.RpcProviderRegistry\" /&gt;&lt;bean id=\"provider\" class=\"org.opendaylight.hello.impl.HelloProvider\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;argument ref=\"dataBroker\" /&gt; &lt;argument ref=\"rpcRegistry\" /&gt;&lt;/bean&gt;&lt;/blueprint&gt; &gt; 这个文档中添加了`rpcRegistry`。需要注意&lt;?xml&gt;前不能有空格。 然后回到hello/impl目录下编译。 1mvn clean install 回到hello目录下编译。 1mvn clean install 通过REST来测试hello-world RPC 有很多方式可以测试RPC, 比如以下两种。 通过HTTP使用ODL控制器自带的API Explorer 使用浏览器的REST 客户端 通过HTTP使用ODL控制器自带的API Explorer 使用浏览器进入 apidoc UI&lt;http://localhost:8181/apidoc/explorer/index.html&gt; 。 TIP: localhost是你ODL控制器的IP地址或者Hostname。 选择 12hello(2015-01-05) 选择 12POST /operations/hello:hello-world 在框内填写如下值 12&#123;\"hello:input\": &#123; \"name\":\"Your Name\"&#125;&#125; 点击按钮. 输入 username 和 password, 默认是admin/admin. 返回的Response body应该为： 123456&#123; \"output\": &#123; \"greating\": \"Hello Your Name\" &#125;&#125; 使用浏览器的REST 客户端 可以使用火狐浏览器的 RESTClient或者Chrome的Restlet Client。 1POST: http://192.168.1.43:8181/restconf/operations/hello:hello-world Header: ``` application/json ``` Body: {&quot;input&quot;: { &quot;name&quot;: &quot;Andrew&quot; } } TroubleshootingIf you get a response code 501 while attempting to POST/operations/hello:hello-world, check the file: HelloProvider.java andmake sure the helloService member is being set. By not invoking“session.addRpcImplementation()” the REST API will be unable to map/operations/hello:hello-world url to HelloWorldImpl. 这个应该碰不到了。所以就不翻译了。","tags":[{"name":"SDN","slug":"SDN","permalink":"https://nachtz.github.io/tags/SDN/"}]},{"title":"Smarking Algorithm Contest 3","date":"2016-11-06T06:37:31.000Z","path":"2016/11/06/Smarking Algorithm Contest 3/","text":"1. 453. Minimum Moves to Equal Array ElementsGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.Ex:12345678910Input:[1,2,3]Output:3Explanation:Only three moves are needed (remember each move increments two elements):[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 给一个长度为n的非空数组，将这个数组中的其中n-1个元素都+1，称为一次操作。求出将这个数组所有元素都变为相同大小的操作的次数。解法：12345678910111213141516func minMoves(nums []int) int &#123; if len(nums) &lt;= 1&#123; return 0 &#125; sum,min,max := nums[0],nums[0],nums[0] for i:=1;i&lt;len(nums);i++&#123; sum += nums[i] if min &gt; nums[i]&#123; min = nums[i] &#125; if max &lt; nums[i]&#123; max = nums[i] &#125; &#125; return sum - len(nums)*min&#125; 2. 447. Number of BoomerangsGiven n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).Ex:12345678Input:[[0,0],[1,0],[2,0]]Output:2Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 给定平面内的坐标。求出这些坐标中，一个点到另外两个点距离相同的组合。这题只要求出每个坐标到其他坐标的距离。然后再遍历就行了。 1234567891011121314151617181920212223242526272829303132func pow(t int) int&#123; return t*t&#125;func numberOfBoomerangs(points [][]int) int &#123; if len(points) &lt;3&#123; return 0 &#125; dis := make([][]int,len(points)) for i:=0;i&lt;len(points);i++&#123; dis[i] = make([]int,len(points)) &#125; for i:=0;i&lt;len(points);i++&#123; for j:=i+1;j&lt;len(points);j++&#123; t := pow(points[i][0] - points[j][0])+pow(points[i][1] - points[j][1]) dis[i][j],dis[j][i] = t,t &#125; &#125; count := 0 for i:=0;i&lt;len(points);i++&#123; for j:=0;j&lt;len(points);j++&#123; if j == i&#123; continue &#125; for k := j+1;k&lt;len(points);k++&#123; if dis[i][j] == dis[i][k]&#123; count +=2 &#125; &#125; &#125; &#125; return count&#125; 3. 452. Minimum Number of Arrows to Burst BalloonsThere are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.Ex:12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 这题把一堆乱七八糟的背景剥开后，题目实际上是这样的：给定一组区间，然后要你给出长度最小的一组数，这组数中所有的点都在区间内而且没有区间被遗漏。用贪心算法就可以做。将区间按起点从小到大排列。然后每一次都选一个点，能够尽量的覆盖到最多的区间。直到不能覆盖为止。依次取点，直到区间都有点落在上面。1234567891011121314151617181920212223242526272829303132333435363738394041type ranges [][]int func(r ranges)Len() int&#123; return len(r)&#125;func(r ranges)Less(i,j int)bool&#123; if r[i][0] != r[j][0]&#123; return r[i][0]&lt;r[j][0] &#125; return r[i][1]&lt;r[j][1]&#125;func (r ranges)Swap(i,j int)&#123; r[i][0],r[j][0] = r[j][0],r[i][0] r[j][1],r[i][1] = r[i][1],r[j][1]&#125;func findMinArrowShots(points [][]int) int &#123; p := ranges(points) sort.Sort(p) count := 0 for i:=0;i&lt;len(p);i++&#123; count ++ j := i+1 at := p[i][1] for j = i+1;j&lt;len(p) ;j++&#123; if p[j][0]&gt;at&#123; i = j-1 break &#125; if p[j][1] &lt; at&#123; at = p[j][1] &#125; &#125; if j == len(p)&#123; break &#125; &#125; return count&#125; 4. 446. Arithmetic Slices II - SubsequenceA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, …, Pk) such that 0 ≤ P0 &lt; P1 &lt; … &lt; Pk &lt; N. A subsequence slice (P0, P1, …, Pk) of array A is called arithmetic if the sequence A[P0], A[P1], …, A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A. Ex:12345678910111213Input: [2, 4, 6, 8, 10]Output: 7Explanation:All arithmetic subsequence slices are:[2,4,6][4,6,8][6,8,10][2,4,6,8][4,6,8,10][2,4,6,8,10][2,6,10] 这题试了下DFS会超时，用DP做会MLE。最后没做出来。给个别人的代码：123456789101112131415161718192021222324class Solution(object): def numberOfArithmeticSlices(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" ans=0 dp = [] for i in range(len(A)): a=A[i] dp.append(&#123;&#125;) for j in range(i): b=A[j] d=a-b if d in dp[j]: v=1+dp[j][d] else: v=1 if d in dp[i]: dp[i][d]=dp[i][d]+v else: dp[i][d]=v ans += sum([dp[i][x] for x in dp[i]]) - i return ans","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"Smarking Algorithm Contest 2","date":"2016-10-30T04:21:31.000Z","path":"2016/10/30/Smarking Algorithm Contest 2/","text":"435. Non-overlapping IntervalsGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note: You may assume the interval’s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders “touching” but they don’t overlap each other. 给定一组区间，你可以移除一些区间让这组区间互不重叠。 做法是： 首先将区间按照起点大小排序。 将区间中所有完全覆盖其他区间的区间移除掉。 在剩下的区间中，如果有区间，和它之前的区间有重叠，就移除它。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859type arrI []Intervalfunc (a arrI)Len() int&#123; return len(a)&#125;func (a arrI)Less(i,j int) bool&#123; if a[i].Start!=a[j].Start&#123; return a[i].Start&lt;a[j].Start &#125; return a[i].End&gt;=a[j].End&#125;func (a arrI)Swap(i,j int)&#123; a[i],a[j] = a[j],a[i]&#125;func eraseOverlapIntervals(intervals []Interval) int &#123; if len(intervals) &lt;= 1&#123; return 0 &#125; tmp := arrI(intervals) sort.Sort(tmp) res := tmp[0] count :=0 ret := []Interval&#123;&#125; for i:=0;i&lt;len(tmp);i++&#123; flag := false if len(ret)&gt;0 &amp;&amp; tmp[i].Start &lt;= ret[len(ret)-1].Start&#123; flag = true count ++ &#125;else&#123; for j:=i+1;j&lt;len(tmp);j++&#123; if tmp[i].End &lt;= tmp[j].Start&#123; break &#125; if tmp[i].End &gt;= tmp[j].End&#123; flag = true count ++ break &#125; &#125; &#125; if !flag&#123; ret = append(ret,tmp[i]) &#125; &#125; if len(ret) == 0&#123; return count &#125; res =ret[0] for i:=1;i&lt;len(ret);i++&#123; if ret[i].Start &gt;= res.End&#123; res = ret[i] &#125;else&#123; count ++ &#125; &#125; return count&#125; 436. Find Right IntervalGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i. For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note: You may assume the interval’s end point is always bigger than its start point. You may assume none of these intervals have the same start point.给定一组区间，对于每一个区间，如果有其他区间的起点大于等于这个区间的终点，那么就称这个区间有右区间。找出最近的右区间的下标。没有右区间则该区间的最小右区间为-1。 这题直接用o(n*n)的算法就能过。即一个个找右区间。 123456789101112131415161718192021func findRightInterval(intervals []Interval) []int &#123; ret := make([]int,len(intervals)) for i:=0;i&lt;len(intervals);i++&#123; min := i for j:=0;j&lt;len(intervals);j++&#123; if j == i&#123; continue &#125; if intervals[j].Start &gt;= intervals[i].End&#123; if min == i || intervals[j].Start &lt; intervals[min].Start&#123; min = j &#125; &#125; &#125; if min == i&#123; min = -1 &#125; ret[i] = min &#125; return ret&#125; 441. Arranging CoinsYou have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. 水题，没啥好说的。12345678func arrangeCoins(n int) int &#123; idx :=1; for (n&gt;=idx)&#123; n -=idx idx ++ &#125; return idx-1&#125; 444. Sequence ReconstructionCheck whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 10^4. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence. link没做出来，贴个别人的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: bool sequenceReconstruction(vector&lt;int&gt;&amp; org, vector&lt;vector&lt;int&gt;&gt;&amp; seqs) &#123; int n = org.size(); vector&lt;int&gt; to(n), in(n); vector&lt;bool&gt; vis(n); vector&lt;vector&lt;int&gt;&gt; adj(n); int k = 0; for (auto &amp;x : org) &#123; x--; to[x] = k++; &#125; for (auto &amp;vec : seqs) &#123; for (auto &amp;c : vec) &#123; c--; if (c &lt; 0 || c &gt;= n) &#123; return false; &#125; vis[to[c]] = true; &#125; for (int i = 1; i &lt; vec.size(); i++) &#123; auto x = to[vec[i - 1]], y = to[vec[i]]; adj[x].push_back(y); in[y]++; if (x &gt; y) &#123; return false; &#125; &#125; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i]) &#123; return false; &#125; if (!in[i]) &#123; q.push(i); &#125; &#125; vector&lt;int&gt; sorted; while (!q.empty()) &#123; if (q.size() &gt; 1) &#123; return false; &#125; auto s = q.front(); q.pop(); sorted.push_back(s); for (auto v : adj[s]) &#123; if (!--in[v]) &#123; q.push(v); &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i != sorted[i]) &#123; return false; &#125; &#125; return true; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"Leetcode第十周周赛Smarking Algorithm Contest","date":"2016-10-23T06:37:31.000Z","path":"2016/10/23/leetcode_weekly_contest10/","text":"437. Path Sum IIIYou are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 给你个树，求出所有符合路径上的节点的值的和等于给定值这个条件的路径的个数。路径要求是自上而下，但是不要求从根出发，也不要求以叶子节点作为结尾。挂在这道题上面了。给个别人的解法：将路径分为两种走法，每个节点都有两种走法。第一种情况是以这个节点为起点，开始出发。第二种是继承之前的走法接着走下去。12345678910111213141516171819202122232425262728var res intfunc go2(root *TreeNode, need int)&#123; if root == nil&#123; return &#125; if need == 0&#123; res ++ &#125; if root.Left != nil&#123; go2(root.Left,need-root.Left.Val) &#125; if root.Right != nil&#123; go2(root.Right,need-root.Right.Val) &#125;&#125;func go1(root * TreeNode, need int)&#123; if root == nil&#123; return &#125; go2(root,need-root.Val) go1(root.Left,need) go1(root.Right,need)&#125;func pathSum(root *TreeNode, sum int) int &#123; res = 0 go1(root, sum) return res&#125; 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter.Example 1:123456789Input:s: \"cbaebabacd\" p: \"abc\"Output:[0, 6]Explanation:The substring with start index = 0 is \"cba\", which is an anagram of \"abc\".The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2:12345678910Input:s: \"abab\" p: \"ab\"Output:[0, 1, 2]Explanation:The substring with start index = 0 is \"ab\", which is an anagram of \"ab\".The substring with start index = 1 is \"ba\", which is an anagram of \"ab\".The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". 给定两个字符串s,p，求出p的所有变形（包括自己）在s中的起点。解法是统计p中的词频，然后统计s中i到i+len(p)中的字符串的词频。相比较，如果相等则说明命中了。123456789101112131415161718192021222324252627282930313233func check(a,b,c [26]int) bool&#123; for i:=0;i&lt;26;i++&#123; if a[i]-b[i] != c[i]&#123; return false &#125; &#125; return true&#125;func findAnagrams(s string, p string) []int &#123; if len(s)&lt;len(p)&#123; return []int&#123;&#125; &#125; ret := []int&#123;&#125; start, end, mark := [26]int&#123;&#125;,[26]int&#123;&#125;,[26]int&#123;&#125; for i:=0;i&lt;len(p);i++&#123; mark[p[i]-'a'] ++ &#125; for i:=0;i&lt;len(p);i++&#123; end[s[i]-'a'] ++ &#125; if check(end,start,mark)&#123; ret = append(ret,0) &#125; for i:=len(p);i&lt;len(s);i++&#123; start[s[i-len(p)]-'a'] ++ end[s[i]-'a']++ if check(end,start,mark)&#123; ret = append(ret,i-len(p)+1) &#125; &#125; return ret&#125; 439. Ternary Expression ParserGiven a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively). Note: The length of the given string is ≤ 10000. Each number will contain only one digit. The conditional expressions group right-to-left (as usual in most languages). The condition will always be either T or F. That is, the condition will never be a digit. The result of the expression will always evaluate to either a digit 0-9, T or F.Example 1:123Input: \"T?2:3\"Output: \"2\"Explanation: If true, then result is 2; otherwise result is 3. Example 2:1234567891011121314Input: \"F?1:T?4:5\"Output: \"4\"Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: \"(F ? 1 : (T ? 4 : 5))\" \"(F ? 1 : (T ? 4 : 5))\" -&gt; \"(F ? 1 : 4)\" or -&gt; \"(T ? 4 : 5)\" -&gt; \"4\" -&gt; \"4\"``` 就是C语言中常见的`?:`语句。这题可以利用栈来做，也可以利用递归来做，应该也可以用正则表达式来做。下面是递归的做法： func parseTernary(e string) string { if e[0] != ‘T’ &amp;&amp; e[0]!=’F’{ return e } c1,c2,i := 0,0,1 for i=1;i","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 9 第九周周赛","date":"2016-10-16T06:11:31.000Z","path":"2016/10/16/leetcode_weekly_contest9/","text":"422. Valid Word SquareGiven a sequence of words, check whether it forms a valid word square. A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns).Note: 1. The number of words given is at least 1 and does not exceed 500. 2. Word length will be at least 1 and does not exceed 500. 3. Each word contains only lowercase English alphabet a-z. 大致就是讲给定一组string数组，判断string数组是不是符合要求。要求方块横着读和竖着读是一样的。直接判断就行了。golang AC代码：123456789101112131415161718func validWordSquare(words []string) bool &#123; str := \"\" for i:=0 ;i&lt; len(words);i++&#123; str = \"\" for j:=0;j&lt;len(words);j++&#123; if i &lt; len(words[j])&#123; str += string(words[j][i]) &#125;else&#123; break &#125; &#125; if str != words[i]&#123; return false &#125; &#125; return true&#125; 423. Reconstruct Original Digits from EnglishGiven a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note: Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as “abc” or “zerone” are not permitted. Input length is less than 50,000. 给一串乱序的字母序列，求这个字母序列重组之后所代表的数字串。比如：123Input: \"owoztneoer\"Output: \"012\" 题目中说给出的字母序列都是必定合法而且唯一的。 这题主要是根据0-9的英文中独占的字母来进行判断的。判断的顺序如下： 数字 英文 字母 0 zero z 6 six s 2 two w 7 seven s 4 four u 5 five v 1 one o 9 nine n 8 eight i 3 three t 从表的第一项开始，我们首先可以通过z的个数确定0的个数，然后通过s确定6的个数。依次类推。需要注意的是9的个数是n的个数的一半。最后就能得到乱序序列的原来的数字组合了。golang AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980func originalDigits(s string) string &#123; nums := []string&#123;\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"&#125; var count [10]int var acount [26]int for i:=0;i&lt;len(s);i++&#123; acount[int(s[i]-'a')] ++ &#125; if acount[25]&gt;0&#123; str := nums[0] count[0] = acount[25] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[0] &#125; &#125; if (acount[int('x'-'a')]&gt;0)&#123; str := nums[6] count[6] = acount[int('x'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[6] &#125; &#125; if (acount[int('w'-'a')]&gt;0)&#123; str := nums[2] count[2] = acount[int('w'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[2] &#125; &#125; if (acount[int('s'-'a')]&gt;0)&#123; str := nums[7] count[7] = acount[int('s'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[7] &#125; &#125; if (acount[int('u'-'a')]&gt;0)&#123; str := nums[4] count[4] = acount[int('u'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[4] &#125; &#125; if (acount[int('v'-'a')]&gt;0)&#123; str := nums[5] count[5] = acount[int('v'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[5] &#125; &#125; if (acount[int('o'-'a')]&gt;0)&#123; str := nums[1] count[1] = acount[int('o'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[1] &#125; &#125; if (acount[int('n'-'a')]&gt;0)&#123; str := nums[9] count[9] = acount[int('n'-'a')]/2 for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[9] &#125; &#125; if (acount[int('i'-'a')]&gt;0)&#123; str := nums[8] count[8] = acount[int('i'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[8] &#125; &#125; count[3] = acount[int('r'-'a')] str := \"\" for i:=0;i&lt;=9;i++&#123; for j:=0;j&lt;count[i];j++&#123; str += string(i+'0') &#125; &#125; return str&#125; 424. Longest Repeating Character ReplacementGiven a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.给定一串仅由大写字母组成的字符串，和一个数字k。假定这个字符串最多有k个字母能被替换成其他字母。求这个替换的过程中，最长的连续重复序列的长度。这道题可以用枚举法，先假设以求最长的连续的A,那么在整个序列中，把不是A的点都标出来。然后看看把这些点中的某K个换成A。求出这个换的过程中的最长长度。算法复杂度是o(n).AC golang代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func characterReplacement(s string, k int) int &#123; dp := make([]int,len(s)+1) var ch [26]bool max := 0 if k == 0&#123; length := 1 for i :=1;i&lt;len(s);i++&#123; if s[i-1] == s[i]&#123; length ++ &#125;else&#123; if max &lt; length&#123; max = length &#125; length = 1 &#125; &#125; if max &lt; length&#123; max = length &#125; return max; &#125; //length := 0 for i :=0;i&lt;len(s);i++&#123; ch[s[i]-'A'] = true &#125; for i :=0;i&lt;26;i++&#123; if ch[i] == false&#123; continue &#125; c := 'A' + i // if c == 75&#123; // fmt.Println(\"break\") // &#125; idx :=0 for j:=0;j&lt;len(s);j++&#123; if int(s[j])!=c&#123; dp[idx] = j idx++ //else&#123; // fmt.Print(j,\" \") &#125; &#125; //fmt.Println(\"|\",c) if idx &lt;= k&#123; return len(s) &#125; if max &lt; dp[k]&#123; max = dp[k] &#125; for j:= k+1;j &lt;idx;j++&#123; if dp[j] - dp[j-k-1] - 1 &gt;= max&#123; max = dp[j] - dp[j-k-1] - 1 //fmt.Println(c) &#125; &#125; &#125; return max&#125; 425 Word Squares没做出来，贴一个别人的python代码，用了trie树加dfs：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution(object): def wordSquares(self, words): \"\"\" :type words: List[str] :rtype: List[List[str]] \"\"\" self.l = len(words[0]) self.trie = self.build(words) self.res = [] for word in words: self.dfs(words, self.trie, [word]) return self.res def dfs(self, words, trie, lst): if len(lst) == self.l: self.res.append(lst) return prefix = '' for i in range(len(lst)): prefix += lst[i][len(lst)] for s in self.get(trie, prefix): self.dfs(words, trie, lst + [s]) def build(self, words): trie = &#123;&#125; for word in words: t = trie for c in word: if c not in t: t[c] = &#123;&#125; t = t[c] t['#'] = '#' return trie def get(self, trie, prefix): res = [] t = trie for c in prefix: if c not in t: return res t = t[c] for s in self.getall(t): res.append(prefix + s) return res def getall(self, t): res = [] if '#' in t: return [''] for c in t: if c != '#': for s in self.getall(t[c]): res.append(c + s) return res","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"在Docker中运行DPDK","date":"2016-10-16T04:37:31.000Z","path":"2016/10/16/dpdk_docker/","text":"版本Docker：1.12.1DPDK:16.07 Docker的安装在Ubuntu中docker的安装还是很简单的。参考官方文档^1就行了。需要注意的是只能在64位，linux版本号不低于3.11.0-15-generic的发行版上运行。所以在OpenVZ的VPS上不能运行。 制造DPDK的Docker镜像这边主要参考的是网上的一篇博客^1和红帽的Github[^2]来写Dockerfile的。Dockerfile如下：12345678910111213141516171819FROM ubuntuMAINTAINER NachtZ&lt;nachtz@outlook.com&gt;LABEL RUN docker run -it --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev --name NAME -e NAME=NAME -e IMAGE=IMAGE IMAGE&quot;# Setup yum repos, or use subscription-manager# Install DPDK support packages.RUN apt-get update &amp;&amp; apt-get install -y libpcap-dev wget xz-utils gcc automake autoconf libtool make # Build DPDK and pktgen-dpdk for x86_64-native-linuxapp-gcc.WORKDIR /rootCOPY ./build_dpdk.sh /root/build_dpdk.shCOPY ./dpdk-profile.sh /etc/profile.d/#RUN /root/build_dpdk.sh# Defaults to a bash shell, you could put your DPDK-based application here.CMD [&quot;/bin/bash&quot;] 这个Dockerfile的注解如下：FROM ubuntu：说明该镜像的源镜像是Ubuntu。MAINTAINER NachtZ&lt;nachtz@outlook.com&gt;:介绍镜像的作者。 LABEL RUN docker run -it --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev --name NAME -e NAME=NAME -e· IMAGE=IMAGE IMAGE&quot;: 镜像的标签。 RUN apt-get update &amp;&amp; apt-get install -y libpcap-dev wget xz-utils gcc automake autoconf libtool make：安装DPDK所需要的依赖程序，因为在Docker中的系统都是比较精简的，所以很多程序都需要自己安装。 123WORKDIR /rootCOPY ./build_dpdk.sh /root/build_dpdk.shCOPY ./dpdk-profile.sh /etc/profile.d/ 上面这段话是把Dockerfile同目录下./build_dpdk.sh,./dpdk-profile.sh拷贝到镜像里面去。 CMD [&quot;/bin/bash&quot;]:指定动作是打开一个bash。 到此为止，一个可以用来安装DPDK的镜像就完成了。接下来就是打开它。 在Docker中安装DPDK在shell中运行：docker run -it --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev xxx（最后的xxx表示的是之前的镜像的名字）在运行这个之前，需要将宿主机的DPDK环境都配置好。比如hugepage，以及转载好DPDK驱动的端口。之后运行docker run， --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node 这段话的意思就是给Docker容器权限来使用宿主机的端口，hugepage等。 之后我们进入到Docker的容器中。在容器的root目录下可以看到之前拷贝的./build_dpdk.sh。内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/bin/bash################################################################################## build_dpdk.sh## - Build DPDK and pktgen-dpdk for ## Usage: Adjust variables below before running, if necessary.## MAINTAINER: jeder@redhat.com################################################################################################################################################################### Define Global Variables and Functions################################################################################URL=http://fast.dpdk.org/rel/dpdk-16.04.tar.xzBASEDIR=/rootVERSION=16.04PACKAGE=dpdkDPDKROOT=$BASEDIR/$PACKAGE-$VERSIONCONFIG=x86_64-native-linuxapp-gcc# Download/Build DPDKcd $BASEDIRwget $URLtar -xf $PACKAGE-$VERSION.tar.xzcd $DPDKROOT sed -i 's/CONFIG_RTE_EAL_IGB_UIO=y/CONFIG_RTE_EAL_IGB_UIO=n/' $&#123;DPDKROOT&#125;/config/common_linuxapp \\ &amp;&amp; sed -i 's/CONFIG_RTE_LIBRTE_KNI=y/CONFIG_RTE_LIBRTE_KNI=n/' $&#123;DPDKROOT&#125;/config/common_linuxapp \\ &amp;&amp; sed -i 's/CONFIG_RTE_KNI_KMOD=y/CONFIG_RTE_KNI_KMOD=n/' $&#123;DPDKROOT&#125;/config/common_linuxapp # don't build unnecessary stuff, can be reversed in dpdk_config.shsed -i 's/CONFIG_RTE_APP_TEST=y/CONFIG_RTE_APP_TEST=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_TEST_PMD=y/CONFIG_RTE_TEST_PMD=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_EAL_IGB_UIO=y/CONFIG_RTE_EAL_IGB_UIO=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_LIBRTE_IGB_PMD=y/CONFIG_RTE_LIBRTE_IGB_PMD=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_LIBRTE_IXGBE_PMD=y/CONFIG_RTE_LIBRTE_IXGBE_PMD=n/' $&#123;DPDKROOT&#125;/config/common_base \\make config T=$CONFIGsed -ri 's,(PMD_PCAP=).*,\\1y,' build/.configmake config T=$CONFIG install 这个文档来自^3。我依照DPDK 16.04中的文档和博客[^2]来改造的。在博客[^2]中提到： One thing that is important is to not rely on kernel headers; doing so would be seriously non portable. The uio and igb_uio kernel modules have to be built and installed by the host that will run the DPDK container. Therefore, we configure the SDK to not compile kernel modules, and therefore not require installing kernel headers on the build system. 就是说在Docker中，用到的网卡驱动是宿主机的驱动，所以不需要编译网卡内核驱动。在./build_dpdk.sh中，的两行sed语句就是在修改编译配置。 手动运行完./build_dpdk.sh之后，就可以正常编译运行DPDK的程序了。比如可以：12345$:export RTE_SDK=/root/dpdk-16.04$:export RTE_TARGET=x86_64-native-linuxapp-gcc$:cd dpdk-16.04/example/helloworld$:make$:./build/helloworld 就可以看到helloworld正常的运行了。 Github这是修改完成之后的Docker的Dockerfile和两个sh文件。NachtZ/docker-dpdk 参考资料 Jason的博客[^2] Redhat的dpdk_docker^3 Reference[^2]:Jason 的博客","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"},{"name":"Docker","slug":"Docker","permalink":"https://nachtz.github.io/tags/Docker/"}]},{"title":"LeetCode Weekly Contest 8 第八周周赛","date":"2016-10-09T06:37:31.000Z","path":"2016/10/09/leetcode_weekly_contest8/","text":"不知为何生成该博客会出现内存溢出问题。贴个其他地方的链接。LeetCode Weekly Contest 8 第八周周赛","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 6 第六周周赛","date":"2016-09-25T06:08:49.000Z","path":"2016/09/25/leetcode_weekly_contest6/","text":"404. Sum of Left Leaves不解释123456789101112131415161718func isLeaf(root * TreeNode) bool&#123; if root == nil || root.Left!=nil || root.Right!=nil&#123; return false &#125; return true;&#125;func sumOfLeftLeaves(root *TreeNode) int &#123; res := 0 if root != nil&#123; if isLeaf(root.Left)&#123; res += root.Left.Val &#125;else&#123; res += sumOfLeftLeaves(root.Left) &#125; res += sumOfLeftLeaves(root.Right) &#125; return res&#125; 405. Convert a Number to Hexadecimal常规的10进制转16进制。负数的转换需要先转为补码再计算。注意用long long int 防止溢出。12345678910111213141516171819202122class Solution &#123;public: string toHex(int num) &#123; string a[] = &#123; \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" &#125;; string res; if (num == 0)&#123; return \"0\"; &#125; long long int t; if (num &lt;0)&#123; t = unsigned(num); &#125; else&#123; t = num; &#125; while (t&gt;0)&#123; res = a[t % 16] + res; t /= 16; &#125; return res; &#125;&#125;; 406. Queue Reconstruction by Heighto(n*n)的复杂度。1.将人排序，以前置比他高的人数大小排列，相等的时候按照高度从低到高。2.取排列完第一位，将其取出队列。然后更新下排列中的人情况。即将比他矮的人中，front的人数-1。3.重复操作1，2直到队列中的人都被取出。4.还原队列中的front的情况。因为在第二步中，front的情况会被改写，所以需要恢复。12345678910111213141516171819202122232425262728293031323334353637383940414243type P [][]int func(p P) Len()int&#123; return len(p)&#125;func(p P)Swap(i,j int)&#123; p[i][0],p[i][1],p[j][0],p[j][1] = p[j][0],p[j][1],p[i][0],p[i][1]&#125;func (p P)Less(i,j int)bool&#123; if p[i][1]!=p[j][1]&#123; return p[i][1] &lt; p[j][1] &#125; return p[i][0] &lt; p[j][0]&#125;//1.sort//2.取当前队列func reconstructQueue(people [][]int) [][]int &#123; res := make([][]int,len(people)) for i:=0;i&lt;len(res);i++&#123; res[i] = make([]int,2) &#125; n := len(people) for i:=0;i&lt;n;i++&#123; sort.Sort(P(people)) res[i][0],res[i][1] = people[0][0],people[0][1] for j:=1;j&lt;len(people);j++&#123; if people[0][0] &gt;=people[j][0]&#123; people[j][1] --; &#125; &#125; people = people[1:] &#125; for i :=1;i&lt;len(res);i++ &#123; count :=0 for j :=0;j&lt;i;j++ &#123; if res[i][0] &lt;= res[j][0]&#123; count ++; &#125; &#125; res[i][1] = count &#125; return res;&#125; 407. Trapping Rain Water II下面的做法超时了。正解网上找了一个。11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495func dfs(heightMap [][]int, x,y int)&#123; if x &lt; 0 || x &gt;= len(heightMap) || y &lt;0 || y &gt;= len(heightMap[0])&#123; return &#125; if heightMap[x][y] != 0&#123; return &#125; heightMap[x][y] = 65535 dfs(heightMap,x+1,y) dfs(heightMap,x-1,y) dfs(heightMap,x,y+1) dfs(heightMap,x,y-1)&#125;func getArea(heightMap [][]int) int&#123; for i:=0;i&lt;len(heightMap[0]);i++&#123; dfs(heightMap,0,i) dfs(heightMap,len(heightMap)-1,i) &#125; for i:=0;i&lt;len(heightMap);i++&#123; dfs(heightMap,i,0) dfs(heightMap,i,len(heightMap[0])-1) &#125; count :=0 for i :=0;i&lt;len(heightMap);i++&#123; for j:=0;j&lt;len(heightMap[0]);j++&#123; if heightMap[i][j] == 0&#123; count ++ &#125;else if heightMap[i][j] ==65535&#123; heightMap[i][j] = 0; &#125; &#125; &#125; return count&#125;/*func getMin(heightMap [][]int) int&#123; min := 65535 m,n := len(heightMap),len(heightMap[0]) for i:=1;i&lt;m-1;i++&#123; for j:=1;j&lt;n-1;j++&#123; if heightMap[i][j] == 0&#123; continue; &#125; if min &gt; heightMap[i][j]&#123; min = heightMap[i][j] &#125; &#125; &#125; return min&#125;*/func getMin2(heightMap [][]int) int&#123; min := 65535 m,n := len(heightMap),len(heightMap[0]) for i:=0;i&lt;m;i++&#123; for j:=0;j&lt;n;j++&#123; if heightMap[i][j] == 0&#123; continue; &#125; if min &gt; heightMap[i][j]&#123; min = heightMap[i][j] &#125; &#125; &#125; return min&#125;func trapRainWater(heightMap [][]int) int &#123; res ,tmp:= 0,1 if len(heightMap) == 0 || len(heightMap[0]) == 0&#123; return 0 &#125; for true&#123; m,n := len(heightMap),len(heightMap[0]) min := getMin2(heightMap) for i:=0;i&lt;m;i++&#123; for j:=0;j&lt;n;j++&#123; if heightMap[i][j] &lt; min&#123; heightMap[i][j] = 0 continue; &#125; heightMap[i][j] -= min &#125; &#125; min = getMin2(heightMap) if min == 65535&#123; break &#125; tmp = min* getArea(heightMap) res += tmp &#125; return res&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 5 第五周周赛","date":"2016-09-18T10:10:18.000Z","path":"2016/09/18/leetcode_weekly_contest5/","text":"第一题: 400. Nth Digit这道题用暴力的直接写出从1到n的所有数字组合而成的字符串会超时。一种解法是：先计算出第n个字符是属于哪个数字的。边计算边统计之前的字符个数total。然后得到这个数字后，将这个数字转为字符串，并取n-total-1这个下标的字符，就是所求。123456789101112131415161718func findNthDigit(n int) int &#123; i := 0 mark, l := 1, 0 total := 0 for i = 1; total &lt; n; i++ &#123; if i &gt;= mark &#123; total += l + 1 l++ mark *= 10 &#125; else &#123; total += l &#125; &#125; i-- total -= l t := strconv.Itoa(i) return int(t[n-total-1] - '0')&#125; 第二题：401. Binary Watch没过，应该是题目有问题。题目中说顺序无所谓但是实际上顺序貌似还是有关系的。用二进制来进行计算。先递归的计算出所有可能的num情况。然后将对应的num读为时间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142var b = []int&#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512&#125;var ret []stringfunc readTime(num int) &#123; str := \"\" t := num &gt;&gt; 6 if t &gt;= 12 &#123; return &#125; str += strconv.Itoa(t) + \":\" t = num &amp; 63 if t &gt;= 60 &#123; return &#125; if t &lt; 10 &#123; str += \"0\" + strconv.Itoa(t) &#125; else &#123; str += strconv.Itoa(t) &#125; ret = append(ret, str)&#125;func help(now, num, idx int) &#123; if num == 0 &#123; readTime(now) return &#125; if idx &gt;= 10 &#123; return &#125; help(now, num, idx+1) help(now|b[idx], num-1, idx+1)&#125;func readBinaryWatch(num int) []string &#123; ret = []string&#123;&#125; if num == 0 &#123; return []string&#123;\"0:00\"&#125; &#125; for i := 0; i &lt; len(b); i++ &#123; help(b[i], num-1, i+1) &#125; return ret&#125; 第三题：402. Remove K Digits在裁剪的过程中，如果要裁剪掉k个字符，那么在一个字符串中，前k+1一个字符中一定会有至少一个字符被保留下来。所以算法的目的就是递归的找到这个字符，并对这个字符之后的字符串继续进行裁剪，直到得到最后的结果。另外，题目中要求不能有0，所以在得到结果之后还要去掉首部的0。1234567891011121314151617181920212223242526272829303132333435var res stringfunc help(num string, k int) &#123; if k &lt;= 0&#123; res = res + num return &#125; if k &gt;= len(num)&#123; return ; &#125; minIdx := 0 for i:=1;i&lt;=k;i++&#123; if num[i] &lt; num[minIdx]&#123; minIdx = i &#125; &#125; res = res + string(num[minIdx]) new := num[minIdx+1:] help(new,k - minIdx)&#125;func removeKdigits(num string, k int) string &#123; res = \"\" help(num,k) i:=0 for i=0;i&lt;len(res)&amp;&amp;res[i]=='0';i++&#123; &#125; if i&lt;len(res)&#123; res = res[i:] &#125;else&#123; res = \"0\" &#125; return res&#125; 第四题：403. Frog Jump很明显的递归的例子。用一个映射来讲stones[下标]距离 改成 map[距离]下标.然后从0开始起跳。距离为1。每一次进行判断，首先是是不是最后一个石头了，是则返回true。程序over。然后判断判断下目前所在的石头是哪一个。（检索map[stone[idx]+stp]即可知道，为0即不存在，返回false。）接下来就是继续进行跳跃，分别尝试跳跃stp,stp+1,stp-1的距离即可。需要注意stp==0的时候是没有意义的，直接返回false.1234567891011121314151617181920212223var m map[int]intfunc help(stones []int, idx int, stp int) bool &#123; if stp == 0 &#123; return false &#125; if idx == len(stones)-1 &#123; return true &#125; if m[stones[idx]+stp] == 0 &#123; return false &#125; idx = m[stones[idx]+stp] return help(stones, idx, stp-1) || help(stones, idx, stp+1) || help(stones, idx, stp)&#125;func canCross(stones []int) bool &#123; m = make(map[int]int) for i := 0; i &lt; len(stones); i++ &#123; m[stones[i]] = i &#125; return help(stones, 0, 1)&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 4 第四周周赛","date":"2016-09-12T04:10:18.000Z","path":"2016/09/12/leetcode_weekly_contest4/","text":"用golang做了1，2，4题，第3题golang总是有问题换成c++来做。代码地址：leetcode solution(golang) ###396. Rotate Function###最暴力的方法莫过于一遍一遍计算。可以得到结果。第二种方法就是利用了前一次的结果。假设数组为[a,b,c,d]那么第一次计算的结果就是：0*a + 1*b + 2*c + 3*d第二次计算的结果是（从右往左旋转）：1*a + 2*b + 3*c + 0*d和之前的结果比：差值为：1*a+1*a+1*a-3*d == 1*a+1*a+1*a+1*d - 3*d所以基于前一次的结果f,可以得到下一次的结果的计算公式：t :=f+sum - A[len(A)-i]*len(A) 12345678910111213141516func maxRotateFunction(A []int) int &#123; sum,f:= 0,0 for i:=0;i&lt;len(A);i++&#123; sum += A[i] f += i*A[i] &#125; m := f for i:=1;i&lt;len(A);i++&#123; t :=f+sum - A[len(A)-i]*len(A) if m &lt; t&#123; m = t &#125; f += sum - A[len(A)-i]*len(A) &#125; return m&#125; ###397. Integer Replacement###很简单的递归计算题目。不过这么做复杂度比较高，能过也说明Leetcode的test case 有点简单了。123456789101112131415func integerReplacement(n int) int &#123; if n &lt;= 1&#123; return 0 &#125; if n %2 == 0&#123; return integerReplacement(n/2)+1 &#125;else&#123; t1,t2 := integerReplacement(n+1),integerReplacement(n-1) if t1 &lt;t2&#123; return t1 +1 &#125;else&#123; return t2 +1 &#125; &#125;&#125; ###398. Random Pick Index###这道题的解法，第一种是创建一个hash表map&lt;int,vector&lt;int&gt;&gt;来保存对应的映射关系。在初始化的时候建表。时间复杂度和空间复杂度都是o(n).在检索的时候直接查表取随机值，时间复杂度为o(1).不过最后会出现MLE错误。原因是leetcode这道题考察的点不是hash表，于是将内存限制为o(1).123456789101112131415161718192021222324//MLE代码class Solution &#123;private: unordered_map&lt;int, vector&lt;int&gt;&gt; m;public: Solution(vector&lt;int&gt; nums) &#123; srand(time(0)); for (int i = 0; i&lt;nums.size(); i++)&#123; if (m.count(nums[i]) == 0)&#123; vector&lt;int&gt; t; t.push_back(i); m[nums[i]] = t; &#125; else&#123; m[nums[i]].push_back(i); &#125; &#125; &#125; int pick(int target) &#123; int r = rand() % m[target].size(); return m[target][r]; &#125;&#125;; 这道题实际上考察的是蓄水池抽样，具体的可以看看这篇Blog。利用蓄水池抽样算法，就可以在不知道整个数组长度的情况下，就能保证各个元素获取的概率是相同的。不过貌似不用蓄水池抽样的方法也能通过。12345678910111213141516171819202122class Solution &#123; vector&lt;int&gt; num;public: Solution(vector&lt;int&gt; nums) &#123; num = nums; &#125; int pick(int target) &#123; int index = -1; int count = 0; for (int i = 0; i &lt; num.size(); i++)&#123; if (num[i] == target)&#123; count++; int r = rand() % count + 1; if (r == count)&#123; index = i; &#125; &#125; &#125; return index; &#125;&#125;; 顺带吐槽下leetcode的Golang. 这道题让我意识到Golang不适合在leetcode下刷题用。碰到大数据的题目几乎都会挂，比如109题和239题。还得发邮件给support才能在后台改成通过。这道题的golang解法提示WA。但是错误的test case在本地运行是可以通过的。12345678910111213141516171819202122232425type Solution struct &#123; nums []int&#125;func Constructor(nums []int) Solution &#123; var s Solution s.nums = nums return s&#125;func (this *Solution) Pick(target int) int &#123; idx,count := -1,0 for i:=0;i&lt;len(this.nums);i++&#123; if this.nums[i] == target&#123; count ++ r := rand.Intn(count) + 1 if r== count&#123; idx = i &#125; &#125; &#125; return idx&#125; ###399. Evaluate Division###这种解法最后也能过也是DIAO.o(n*n)的复杂度。遍历两遍。第一遍遍历提供的数据，利用提供的数据计算出所有的两两可提供的结果。比如提供给你 a/b b/c能得到a/b b/a a/a /b/b a/c c/a这几个结果。用map记录这些元素。第二遍遍历第一遍所得到的map进行同样的操作，来二次推导得到的结果。之后的检索操作就是查表操作。没想到这样的方法也能过。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283func calcEquation(equations [][]string, values []float64, query [][]string) []float64 &#123; m := make(map[[2]string]float64) //tm := make(map[string]float64) for i:=0;i&lt;len(equations);i++&#123; a,b :=equations[i][0],equations[i][1] m[[2]string&#123;a,b&#125;] =values[i] m[[2]string&#123;b,a&#125;] = 1/values[i] m[[2]string&#123;a,a&#125;] =1.0 m[[2]string&#123;b,b&#125;] =1.0 for j :=i+1;j&lt;len(equations);j++&#123; //in here to construct the map c,d := equations[j][0],equations[j][1] if a!=c &amp;&amp;a!=d &amp;&amp; b!=c &amp;&amp; b!=d&#123; continue// can't get any new info &#125; if a == c &amp;&amp;b == d || a == d&amp;&amp; b == c&#123; continue// can't get any new info &#125; if a == c&#123; m[[2]string&#123;d,b&#125;] = values[i]/values[j] m[[2]string&#123;b,d&#125;] = values[j]/values[i] &#125; if a == d&#123; m[[2]string&#123;c,b&#125;] = values[i]*values[j] m[[2]string&#123;b,c&#125;] = 1/(values[i]*values[j]) &#125; if b == c&#123; m[[2]string&#123;a,d&#125;] = values[i]*values[j] m[[2]string&#123;d,a&#125;] = 1/(values[j]*values[i]) &#125; if b == d&#123; m[[2]string&#123;a,c&#125;] = values[i]/values[j] m[[2]string&#123;c,a&#125;] = values[j]/values[i] &#125; &#125; &#125; for k,v := range m&#123; a,b := k[0],k[1] m[[2]string&#123;a,b&#125;] =v m[[2]string&#123;b,a&#125;] = 1/v m[[2]string&#123;a,a&#125;] =1.0 m[[2]string&#123;b,b&#125;] =1.0 for k1,v1 := range m&#123; //in here to construct the map c,d := k1[0],k1[1] if a!=c &amp;&amp;a!=d &amp;&amp; b!=c &amp;&amp; b!=d&#123; continue// can't get any new info &#125; if a == c &amp;&amp;b == d || a == d&amp;&amp; b == c&#123; continue// can't get any new info &#125; if a == c&#123; m[[2]string&#123;d,b&#125;] = v/v1 m[[2]string&#123;b,d&#125;] = v1/v &#125; if a == d&#123; m[[2]string&#123;c,b&#125;] = v*v1 m[[2]string&#123;b,c&#125;] = 1/(v*v1) &#125; if b == c&#123; m[[2]string&#123;a,d&#125;] = v*v1 m[[2]string&#123;d,a&#125;] = 1/(v*v1) &#125; if b == d&#123; m[[2]string&#123;a,c&#125;] = v/v1 m[[2]string&#123;c,a&#125;] = v1/v &#125; &#125; &#125; tmp := [2]string&#123;\"\",\"\"&#125; var ret []float64 for i:=0;i&lt;len(query);i++&#123; tmp[0],tmp[1] = query[i][0],query[i][1] v, ok := m[tmp] if ok&#123; ret = append(ret,v) &#125;else&#123; ret = append(ret,-1.0) &#125; &#125; return ret&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"将DPDK移植到snort上的DAQ","date":"2016-08-06T10:16:34.000Z","path":"2016/08/06/dpdk_daq/","text":"DAQ 与Snort在snort-daq中，daq的控制流程是这样的。如上所述，Snort在初始化的时候载入了daq。这个时候snort的所调用的api是daq_load_modules。也就是说，这个时候在主线程没有启动网卡，初始化实例的操作。在初始化整个snort之后（载入配置，载入daq及其他各个模块等等）。snort就进入了分析的阶段了。这个阶段的主角是pig，或者说更本质的，是pig下的analyzer。Snort下面开n个pig线程。pig线程下面调用analyzer来进行包解析。包解析的过程中是在pig线程中多线程并行进行的。每一个analyzer下面都初始化一个daq instance并调用acquire进行抓包并分析。每一个daq instance下面都有一个或多个网卡来获取数据。因为目的主要是介绍daq，所以怎么解析就不提了。从上图和上面的介绍就可以看得出来，一个snort下面有多个daq instance并行运行。每一个daq instance都会进行初始化操作，占用系统资源，获取网卡，抓包，调用callback，之间相互独立。并且是单线程的。 DAQ与DPDK如上面所介绍的。DAQ在设计的时候是单线程的。在本身的实现的几个模块中（Netmap,pcap等等）完全没有涉及到多线程的事情。在snort中的调用也是单线程并行调用的，相互之间各不影响。而Inter的DPDK在多线程方面则有限制。它所初始化的EAL层只能初始化一次。一个程序中只能运行一个dpdk主程序。所以就没有办法在snort中使用多线程。因为如果在snort中使用了多线程。那么实际上每个线程都会去尝试初始化dpdk的EAL。那么就会出错，导致最后只有一个线程能够成功初始化并启动。所以如果要想实现一个支持snort多线程的daq。就需要修改daq中api的逻辑。在实现中，利用线程id来绑定网卡。在daq的content中加入了一个nic-threadid的映射表。然后每个网卡都有一个独立的instance存储原本在daq_content中的信息。然后在线程调用daq相关函数的时候，都会先利用threadid来进行检索这个instance进行操作。通过这个方法就能够将dpdk中的各个网卡独立运行。 Github地址daq_dpdk基于的是dpdk16.04, daq2.1.0,snort 3.0 a04.使用方法在项目主页中。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"},{"name":"Snort","slug":"Snort","permalink":"https://nachtz.github.io/tags/Snort/"}]},{"title":"dpdk_ring剥离（单线程版）","date":"2016-06-17T10:19:59.000Z","path":"2016/06/17/dpdk_ring/","text":"DPDK_RING 剥离(sc)dpdk中的ring结构的原理在官方的doc中有。详细的介绍了单线程和多线程下的ring的结构的实现。其中线程安全的ring的出入队中没有用到锁，这个结构是比较巧妙的。此外，和一般的ring设计相比，dpdk的ring中减少了比较的次数和减法的次数。考虑了很多性能方面的东西。目前就剥离了单线程版的。代码如下： daq_ring.h12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef DAQ_RING_H#define DAQ_RING_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//#include &lt;pthread.h&gt;typedef struct _daq_ring&#123; // pthread_mutex_t mutex; int size; int mask; int cons_head; int cons_tail; int prod_head; int prod_tail; void * ring[0];&#125;;typedef struct _daq_ring daq_ring;//create a ring which can contain size's objects.daq_ring * daq_ring_create(int num);//fre a ring.int daq_ring_free(daq_ring * r);//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r);//see whether a ring is full.int daq_ring_isFull(daq_ring * r);//see the number of objects in ring now.int daq_ring_count(daq_ring * r);//see the size of a ring.int daq_ring_getSize(daq_ring *r);//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r);//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc);//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc);#endif//end of daq_ring.h -daq_ring.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include \"daq_ring.h\"/*typedef struct _daq_ring&#123; pthread_mutex_t mutex; unsigned int size; void * head; void * tail; void * memhead;&#125;daq_ring;*/daq_ring * daq_ring_create(int num)&#123; daq_ring * r = NULL; if(num &lt;=0)return NULL; r = (daq_ring *)malloc(sizeof(daq_ring) + num*sizeof(void*)); if(r == NULL)&#123; return NULL; &#125; r-&gt;size = num; r-&gt;mask = num-1; r-&gt;prod_head = r-&gt;prod_tail = r-&gt;cons_head = r-&gt;cons_tail = 0; // pthread_mutex_init(&amp;r-&gt;mutex,NULL); return r;&#125;//fre a ring.int daq_ring_free(daq_ring * r)&#123; free(r);&#125;//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r)&#123; return r-&gt;cons_tail == r-&gt;prod_tail;&#125;//see whether a ring is full.int daq_ring_isFull(daq_ring * r)&#123; return (((r-&gt;cons_tail - r-&gt;prod_tail -1)&amp;r-&gt;mask)==0);&#125;//see the number of objects in ring now.int daq_ring_count(daq_ring * r)&#123; return ((r-&gt;prod_tail - r-&gt;cons_tail)&amp;r-&gt;mask);&#125;//see the size of a ring.int daq_ring_getSize(daq_ring *r)&#123; return r-&gt;size;&#125;//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r)&#123; return ((r-&gt;cons_tail - r-&gt;prod_tail - 1) &amp; r-&gt;mask);&#125;//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc)&#123; int prod_head = r-&gt;prod_head; int cons_tail = r-&gt;cons_tail; int prod_next = prod_head +1; int mask = r-&gt;mask; int i ; int free = mask + cons_tail -prod_head; if(num &gt;free)&#123; if(free == 0)return 0; num = free; &#125; prod_next = prod_head +num; r-&gt;prod_head = prod_next; &#123; const int size = r-&gt;size; int idx = prod_head &amp; mask; if(idx + num &lt; size)&#123; for (i = 0; i &lt; (num &amp; ((~(unsigned)0x3))); i+=4, idx+=4) &#123; r-&gt;ring[idx] = obj_table[i]; r-&gt;ring[idx+1] = obj_table[i+1]; r-&gt;ring[idx+2] = obj_table[i+2]; r-&gt;ring[idx+3] = obj_table[i+3]; &#125; switch (num &amp; 0x3) &#123; case 3: r-&gt;ring[idx++] = obj_table[i++]; case 2: r-&gt;ring[idx++] = obj_table[i++]; case 1: r-&gt;ring[idx++] = obj_table[i++]; &#125; &#125;else&#123; for (i =0;idx&lt;size;++i,++idx) r-&gt;ring[idx] = obj_table[i]; for(idx = 0;i&lt;num;++i,++idx) r-&gt;ring[idx] = obj_table[i]; &#125; &#125; r-&gt;prod_tail = prod_next; return num;&#125;//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc)&#123; int cons_head,prod_tail; int cons_next,entries; int i; int mask = r-&gt;mask; cons_head = r-&gt;cons_head; prod_tail = r-&gt;prod_tail; entries = prod_tail - cons_head; if(num &gt; entries)&#123; if(entries == 0)return 0; num = entries; &#125; cons_next = cons_head + num; r -&gt; cons_head = cons_next; &#123; int idx = cons_head &amp; mask; int size = r-&gt; size; if (idx + num &lt; size) &#123; for (i = 0; i &lt; (num &amp; (~(unsigned)0x3)); i+=4, idx+=4) &#123; obj_table[i] = r-&gt;ring[idx]; obj_table[i+1] = r-&gt;ring[idx+1]; obj_table[i+2] = r-&gt;ring[idx+2]; obj_table[i+3] = r-&gt;ring[idx+3]; &#125; switch (num &amp; 0x3) &#123; case 3: obj_table[i++] = r-&gt;ring[idx++]; case 2: obj_table[i++] = r-&gt;ring[idx++]; case 1: obj_table[i++] = r-&gt;ring[idx++]; &#125; &#125; else &#123; for (i = 0; idx &lt; size; i++, idx++) obj_table[i] = r-&gt;ring[idx]; for (idx = 0; i &lt; num; i++, idx++) obj_table[i] = r-&gt;ring[idx]; &#125; &#125; r-&gt;cons_tail = cons_next; return num;&#125;void daq_ring_stat(daq_ring * r)&#123; printf(\"***********************************************\\n\"); printf(\"Daq_ring's size is %d\\n\",daq_ring_getSize(r)); printf(\"Daq_ring's objects now is %d.\\n\",daq_ring_count(r)); printf(\"Daq_ring's free space is %d\\n\",daq_ring_freeCount(r)); printf(\"Daq_ring is %s now.\\n\",daq_ring_isEmpty(r)?\"empty\":\"not empty\"); printf(\"Daq_ring is %s now.\\n\",daq_ring_isFull(r)?\"full\":\"not full\"); printf(\"***********************************************\\n\");&#125;void print_ptr(daq_ring *r)&#123; printf(\"r-&gt;cons:%p %p\\n\", r-&gt;cons_head, r-&gt;cons_tail); printf(\"r-&gt;prod:%p %p\\n\",r-&gt;prod_head,r-&gt;prod_tail); printf(\"r-&gt;ring[0]:%p\\n\",&amp;r-&gt;ring[0]); &#125;int test1()&#123; char * str[] = &#123; \"t1\",\"t2\",\"t3\",\"t4\",\"t5\",\"t6\",\"t7\",\"t8\",\"t9\",\"t10\",\"t11\",\"t12\",\"t13\" &#125;; void * ctx[12]; int i; for(i =0;i&lt;10;++i) printf(\"%s\\n\",str[i]); daq_ring * r = daq_ring_create(9); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(int i =0;i&lt;8;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r);print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(i =0;i&lt;10;++i) printf(\"%s\\n\",(char *)ctx[i]); return 0;&#125;int test2()&#123; int i; char * str[] = &#123; \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\", \"t10\", \"t11\", \"t12\", \"t13\", \"t14\", \"t15\", \"t16\", \"t17\" &#125;; void * ctx[18]; daq_ring * r = daq_ring_create(16); daq_ring_enqueue(r,str,14,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,4,1); for(i =0;i&lt;4;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,&amp;str[5],5,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,15,1); for(i =0;i&lt;15;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r);&#125;int main()&#123; test2(); return 0;&#125;","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]},{"title":"DPDK杂记","date":"2016-06-17T10:19:02.000Z","path":"2016/06/17/dpdk_note/","text":"DPDK编译动态库将common_linuxapp中的CONFIG_RTE_BUILD_SHARED_LIB和CONFIG_RTE_BUILD_COMBINE_LIBS都改为y，重新编译。将生成的lib文件拷贝到linux的lib中。（在dpdk16.04中，combine这个选项被取消了。邮件组中提到说是默认就是combine了。但是实际编译中发现不同的网卡驱动还是没有编译在一起。拷贝的时候都需要拷贝过去。）之后就是修改Makefile.将makefile中的1include $(RTE_SDK)/mk/rteextapp.mk 改为1include $(RTE_SDK)/mk/rte.extshared.mk 把binary name中的app改为1SHARED = yourname.so 最后再加上库：1LDLIBS += -L/home/nachtz/dpdk-2.2.0/x86_64-native-linuxapp-gcc/lib -ldpdk -lrt -lm -lgcc_s -ldl 就行了。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]}]