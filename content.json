[{"title":"LeetCode Weekly Contest 6 第六周周赛","date":"2016-09-25T06:08:49.000Z","path":"2016/09/25/leetcode_weekly_contest6/","text":"404. Sum of Left Leaves不解释123456789101112131415161718func isLeaf(root * TreeNode) bool&#123; if root == nil || root.Left!=nil || root.Right!=nil&#123; return false &#125; return true;&#125;func sumOfLeftLeaves(root *TreeNode) int &#123; res := 0 if root != nil&#123; if isLeaf(root.Left)&#123; res += root.Left.Val &#125;else&#123; res += sumOfLeftLeaves(root.Left) &#125; res += sumOfLeftLeaves(root.Right) &#125; return res&#125; 405. Convert a Number to Hexadecimal常规的10进制转16进制。负数的转换需要先转为补码再计算。注意用long long int 防止溢出。12345678910111213141516171819202122class Solution &#123;public: string toHex(int num) &#123; string a[] = &#123; \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" &#125;; string res; if (num == 0)&#123; return \"0\"; &#125; long long int t; if (num &lt;0)&#123; t = unsigned(num); &#125; else&#123; t = num; &#125; while (t&gt;0)&#123; res = a[t % 16] + res; t /= 16; &#125; return res; &#125;&#125;; 406. Queue Reconstruction by Heighto(n*n)的复杂度。1.将人排序，以前置比他高的人数大小排列，相等的时候按照高度从低到高。2.取排列完第一位，将其取出队列。然后更新下排列中的人情况。即将比他矮的人中，front的人数-1。3.重复操作1，2直到队列中的人都被取出。4.还原队列中的front的情况。因为在第二步中，front的情况会被改写，所以需要恢复。12345678910111213141516171819202122232425262728293031323334353637383940414243type P [][]int func(p P) Len()int&#123; return len(p)&#125;func(p P)Swap(i,j int)&#123; p[i][0],p[i][1],p[j][0],p[j][1] = p[j][0],p[j][1],p[i][0],p[i][1]&#125;func (p P)Less(i,j int)bool&#123; if p[i][1]!=p[j][1]&#123; return p[i][1] &lt; p[j][1] &#125; return p[i][0] &lt; p[j][0]&#125;//1.sort//2.取当前队列func reconstructQueue(people [][]int) [][]int &#123; res := make([][]int,len(people)) for i:=0;i&lt;len(res);i++&#123; res[i] = make([]int,2) &#125; n := len(people) for i:=0;i&lt;n;i++&#123; sort.Sort(P(people)) res[i][0],res[i][1] = people[0][0],people[0][1] for j:=1;j&lt;len(people);j++&#123; if people[0][0] &gt;=people[j][0]&#123; people[j][1] --; &#125; &#125; people = people[1:] &#125; for i :=1;i&lt;len(res);i++ &#123; count :=0 for j :=0;j&lt;i;j++ &#123; if res[i][0] &lt;= res[j][0]&#123; count ++; &#125; &#125; res[i][1] = count &#125; return res;&#125; 407. Trapping Rain Water II下面的做法超时了。正解网上找了一个。11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495func dfs(heightMap [][]int, x,y int)&#123; if x &lt; 0 || x &gt;= len(heightMap) || y &lt;0 || y &gt;= len(heightMap[0])&#123; return &#125; if heightMap[x][y] != 0&#123; return &#125; heightMap[x][y] = 65535 dfs(heightMap,x+1,y) dfs(heightMap,x-1,y) dfs(heightMap,x,y+1) dfs(heightMap,x,y-1)&#125;func getArea(heightMap [][]int) int&#123; for i:=0;i&lt;len(heightMap[0]);i++&#123; dfs(heightMap,0,i) dfs(heightMap,len(heightMap)-1,i) &#125; for i:=0;i&lt;len(heightMap);i++&#123; dfs(heightMap,i,0) dfs(heightMap,i,len(heightMap[0])-1) &#125; count :=0 for i :=0;i&lt;len(heightMap);i++&#123; for j:=0;j&lt;len(heightMap[0]);j++&#123; if heightMap[i][j] == 0&#123; count ++ &#125;else if heightMap[i][j] ==65535&#123; heightMap[i][j] = 0; &#125; &#125; &#125; return count&#125;/*func getMin(heightMap [][]int) int&#123; min := 65535 m,n := len(heightMap),len(heightMap[0]) for i:=1;i&lt;m-1;i++&#123; for j:=1;j&lt;n-1;j++&#123; if heightMap[i][j] == 0&#123; continue; &#125; if min &gt; heightMap[i][j]&#123; min = heightMap[i][j] &#125; &#125; &#125; return min&#125;*/func getMin2(heightMap [][]int) int&#123; min := 65535 m,n := len(heightMap),len(heightMap[0]) for i:=0;i&lt;m;i++&#123; for j:=0;j&lt;n;j++&#123; if heightMap[i][j] == 0&#123; continue; &#125; if min &gt; heightMap[i][j]&#123; min = heightMap[i][j] &#125; &#125; &#125; return min&#125;func trapRainWater(heightMap [][]int) int &#123; res ,tmp:= 0,1 if len(heightMap) == 0 || len(heightMap[0]) == 0&#123; return 0 &#125; for true&#123; m,n := len(heightMap),len(heightMap[0]) min := getMin2(heightMap) for i:=0;i&lt;m;i++&#123; for j:=0;j&lt;n;j++&#123; if heightMap[i][j] &lt; min&#123; heightMap[i][j] = 0 continue; &#125; heightMap[i][j] -= min &#125; &#125; min = getMin2(heightMap) if min == 65535&#123; break &#125; tmp = min* getArea(heightMap) res += tmp &#125; return res&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 5 第五周周赛","date":"2016-09-18T10:10:18.000Z","path":"2016/09/18/leetcode_weekly_contest5/","text":"第一题: 400. Nth Digit这道题用暴力的直接写出从1到n的所有数字组合而成的字符串会超时。一种解法是：先计算出第n个字符是属于哪个数字的。边计算边统计之前的字符个数total。然后得到这个数字后，将这个数字转为字符串，并取n-total-1这个下标的字符，就是所求。123456789101112131415161718func findNthDigit(n int) int &#123; i := 0 mark, l := 1, 0 total := 0 for i = 1; total &lt; n; i++ &#123; if i &gt;= mark &#123; total += l + 1 l++ mark *= 10 &#125; else &#123; total += l &#125; &#125; i-- total -= l t := strconv.Itoa(i) return int(t[n-total-1] - '0')&#125; 第二题：401. Binary Watch没过，应该是题目有问题。题目中说顺序无所谓但是实际上顺序貌似还是有关系的。用二进制来进行计算。先递归的计算出所有可能的num情况。然后将对应的num读为时间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142var b = []int&#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512&#125;var ret []stringfunc readTime(num int) &#123; str := \"\" t := num &gt;&gt; 6 if t &gt;= 12 &#123; return &#125; str += strconv.Itoa(t) + \":\" t = num &amp; 63 if t &gt;= 60 &#123; return &#125; if t &lt; 10 &#123; str += \"0\" + strconv.Itoa(t) &#125; else &#123; str += strconv.Itoa(t) &#125; ret = append(ret, str)&#125;func help(now, num, idx int) &#123; if num == 0 &#123; readTime(now) return &#125; if idx &gt;= 10 &#123; return &#125; help(now, num, idx+1) help(now|b[idx], num-1, idx+1)&#125;func readBinaryWatch(num int) []string &#123; ret = []string&#123;&#125; if num == 0 &#123; return []string&#123;\"0:00\"&#125; &#125; for i := 0; i &lt; len(b); i++ &#123; help(b[i], num-1, i+1) &#125; return ret&#125; 第三题：402. Remove K Digits在裁剪的过程中，如果要裁剪掉k个字符，那么在一个字符串中，前k+1一个字符中一定会有至少一个字符被保留下来。所以算法的目的就是递归的找到这个字符，并对这个字符之后的字符串继续进行裁剪，直到得到最后的结果。另外，题目中要求不能有0，所以在得到结果之后还要去掉首部的0。1234567891011121314151617181920212223242526272829303132333435var res stringfunc help(num string, k int) &#123; if k &lt;= 0&#123; res = res + num return &#125; if k &gt;= len(num)&#123; return ; &#125; minIdx := 0 for i:=1;i&lt;=k;i++&#123; if num[i] &lt; num[minIdx]&#123; minIdx = i &#125; &#125; res = res + string(num[minIdx]) new := num[minIdx+1:] help(new,k - minIdx)&#125;func removeKdigits(num string, k int) string &#123; res = \"\" help(num,k) i:=0 for i=0;i&lt;len(res)&amp;&amp;res[i]=='0';i++&#123; &#125; if i&lt;len(res)&#123; res = res[i:] &#125;else&#123; res = \"0\" &#125; return res&#125; 第四题：403. Frog Jump很明显的递归的例子。用一个映射来讲stones[下标]距离 改成 map[距离]下标.然后从0开始起跳。距离为1。每一次进行判断，首先是是不是最后一个石头了，是则返回true。程序over。然后判断判断下目前所在的石头是哪一个。（检索map[stone[idx]+stp]即可知道，为0即不存在，返回false。）接下来就是继续进行跳跃，分别尝试跳跃stp,stp+1,stp-1的距离即可。需要注意stp==0的时候是没有意义的，直接返回false.1234567891011121314151617181920212223var m map[int]intfunc help(stones []int, idx int, stp int) bool &#123; if stp == 0 &#123; return false &#125; if idx == len(stones)-1 &#123; return true &#125; if m[stones[idx]+stp] == 0 &#123; return false &#125; idx = m[stones[idx]+stp] return help(stones, idx, stp-1) || help(stones, idx, stp+1) || help(stones, idx, stp)&#125;func canCross(stones []int) bool &#123; m = make(map[int]int) for i := 0; i &lt; len(stones); i++ &#123; m[stones[i]] = i &#125; return help(stones, 0, 1)&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 4 第四周周赛","date":"2016-09-12T04:10:18.000Z","path":"2016/09/12/leetcode_weekly_contest4/","text":"用golang做了1，2，4题，第3题golang总是有问题换成c++来做。代码地址：leetcode solution(golang) ###396. Rotate Function###最暴力的方法莫过于一遍一遍计算。可以得到结果。第二种方法就是利用了前一次的结果。假设数组为[a,b,c,d]那么第一次计算的结果就是：0*a + 1*b + 2*c + 3*d第二次计算的结果是（从右往左旋转）：1*a + 2*b + 3*c + 0*d和之前的结果比：差值为：1*a+1*a+1*a-3*d == 1*a+1*a+1*a+1*d - 3*d所以基于前一次的结果f,可以得到下一次的结果的计算公式：t :=f+sum - A[len(A)-i]*len(A) 12345678910111213141516func maxRotateFunction(A []int) int &#123; sum,f:= 0,0 for i:=0;i&lt;len(A);i++&#123; sum += A[i] f += i*A[i] &#125; m := f for i:=1;i&lt;len(A);i++&#123; t :=f+sum - A[len(A)-i]*len(A) if m &lt; t&#123; m = t &#125; f += sum - A[len(A)-i]*len(A) &#125; return m&#125; ###397. Integer Replacement###很简单的递归计算题目。不过这么做复杂度比较高，能过也说明Leetcode的test case 有点简单了。123456789101112131415func integerReplacement(n int) int &#123; if n &lt;= 1&#123; return 0 &#125; if n %2 == 0&#123; return integerReplacement(n/2)+1 &#125;else&#123; t1,t2 := integerReplacement(n+1),integerReplacement(n-1) if t1 &lt;t2&#123; return t1 +1 &#125;else&#123; return t2 +1 &#125; &#125;&#125; ###398. Random Pick Index###这道题的解法，第一种是创建一个hash表map&lt;int,vector&lt;int&gt;&gt;来保存对应的映射关系。在初始化的时候建表。时间复杂度和空间复杂度都是o(n).在检索的时候直接查表取随机值，时间复杂度为o(1).不过最后会出现MLE错误。原因是leetcode这道题考察的点不是hash表，于是将内存限制为o(1).123456789101112131415161718192021222324//MLE代码class Solution &#123;private: unordered_map&lt;int, vector&lt;int&gt;&gt; m;public: Solution(vector&lt;int&gt; nums) &#123; srand(time(0)); for (int i = 0; i&lt;nums.size(); i++)&#123; if (m.count(nums[i]) == 0)&#123; vector&lt;int&gt; t; t.push_back(i); m[nums[i]] = t; &#125; else&#123; m[nums[i]].push_back(i); &#125; &#125; &#125; int pick(int target) &#123; int r = rand() % m[target].size(); return m[target][r]; &#125;&#125;; 这道题实际上考察的是蓄水池抽样，具体的可以看看这篇Blog。利用蓄水池抽样算法，就可以在不知道整个数组长度的情况下，就能保证各个元素获取的概率是相同的。不过貌似不用蓄水池抽样的方法也能通过。12345678910111213141516171819202122class Solution &#123; vector&lt;int&gt; num;public: Solution(vector&lt;int&gt; nums) &#123; num = nums; &#125; int pick(int target) &#123; int index = -1; int count = 0; for (int i = 0; i &lt; num.size(); i++)&#123; if (num[i] == target)&#123; count++; int r = rand() % count + 1; if (r == count)&#123; index = i; &#125; &#125; &#125; return index; &#125;&#125;; 顺带吐槽下leetcode的Golang. 这道题让我意识到Golang不适合在leetcode下刷题用。碰到大数据的题目几乎都会挂，比如109题和239题。还得发邮件给support才能在后台改成通过。这道题的golang解法提示WA。但是错误的test case在本地运行是可以通过的。12345678910111213141516171819202122232425type Solution struct &#123; nums []int&#125;func Constructor(nums []int) Solution &#123; var s Solution s.nums = nums return s&#125;func (this *Solution) Pick(target int) int &#123; idx,count := -1,0 for i:=0;i&lt;len(this.nums);i++&#123; if this.nums[i] == target&#123; count ++ r := rand.Intn(count) + 1 if r== count&#123; idx = i &#125; &#125; &#125; return idx&#125; ###399. Evaluate Division###这种解法最后也能过也是DIAO.o(n*n)的复杂度。遍历两遍。第一遍遍历提供的数据，利用提供的数据计算出所有的两两可提供的结果。比如提供给你 a/b b/c能得到a/b b/a a/a /b/b a/c c/a这几个结果。用map记录这些元素。第二遍遍历第一遍所得到的map进行同样的操作，来二次推导得到的结果。之后的检索操作就是查表操作。没想到这样的方法也能过。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283func calcEquation(equations [][]string, values []float64, query [][]string) []float64 &#123; m := make(map[[2]string]float64) //tm := make(map[string]float64) for i:=0;i&lt;len(equations);i++&#123; a,b :=equations[i][0],equations[i][1] m[[2]string&#123;a,b&#125;] =values[i] m[[2]string&#123;b,a&#125;] = 1/values[i] m[[2]string&#123;a,a&#125;] =1.0 m[[2]string&#123;b,b&#125;] =1.0 for j :=i+1;j&lt;len(equations);j++&#123; //in here to construct the map c,d := equations[j][0],equations[j][1] if a!=c &amp;&amp;a!=d &amp;&amp; b!=c &amp;&amp; b!=d&#123; continue// can't get any new info &#125; if a == c &amp;&amp;b == d || a == d&amp;&amp; b == c&#123; continue// can't get any new info &#125; if a == c&#123; m[[2]string&#123;d,b&#125;] = values[i]/values[j] m[[2]string&#123;b,d&#125;] = values[j]/values[i] &#125; if a == d&#123; m[[2]string&#123;c,b&#125;] = values[i]*values[j] m[[2]string&#123;b,c&#125;] = 1/(values[i]*values[j]) &#125; if b == c&#123; m[[2]string&#123;a,d&#125;] = values[i]*values[j] m[[2]string&#123;d,a&#125;] = 1/(values[j]*values[i]) &#125; if b == d&#123; m[[2]string&#123;a,c&#125;] = values[i]/values[j] m[[2]string&#123;c,a&#125;] = values[j]/values[i] &#125; &#125; &#125; for k,v := range m&#123; a,b := k[0],k[1] m[[2]string&#123;a,b&#125;] =v m[[2]string&#123;b,a&#125;] = 1/v m[[2]string&#123;a,a&#125;] =1.0 m[[2]string&#123;b,b&#125;] =1.0 for k1,v1 := range m&#123; //in here to construct the map c,d := k1[0],k1[1] if a!=c &amp;&amp;a!=d &amp;&amp; b!=c &amp;&amp; b!=d&#123; continue// can't get any new info &#125; if a == c &amp;&amp;b == d || a == d&amp;&amp; b == c&#123; continue// can't get any new info &#125; if a == c&#123; m[[2]string&#123;d,b&#125;] = v/v1 m[[2]string&#123;b,d&#125;] = v1/v &#125; if a == d&#123; m[[2]string&#123;c,b&#125;] = v*v1 m[[2]string&#123;b,c&#125;] = 1/(v*v1) &#125; if b == c&#123; m[[2]string&#123;a,d&#125;] = v*v1 m[[2]string&#123;d,a&#125;] = 1/(v*v1) &#125; if b == d&#123; m[[2]string&#123;a,c&#125;] = v/v1 m[[2]string&#123;c,a&#125;] = v1/v &#125; &#125; &#125; tmp := [2]string&#123;\"\",\"\"&#125; var ret []float64 for i:=0;i&lt;len(query);i++&#123; tmp[0],tmp[1] = query[i][0],query[i][1] v, ok := m[tmp] if ok&#123; ret = append(ret,v) &#125;else&#123; ret = append(ret,-1.0) &#125; &#125; return ret&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"将DPDK移植到snort上的DAQ","date":"2016-08-06T10:16:34.000Z","path":"2016/08/06/dpdk_daq/","text":"DAQ 与Snort在snort-daq中，daq的控制流程是这样的。如上所述，Snort在初始化的时候载入了daq。这个时候snort的所调用的api是daq_load_modules。也就是说，这个时候在主线程没有启动网卡，初始化实例的操作。在初始化整个snort之后（载入配置，载入daq及其他各个模块等等）。snort就进入了分析的阶段了。这个阶段的主角是pig，或者说更本质的，是pig下的analyzer。Snort下面开n个pig线程。pig线程下面调用analyzer来进行包解析。包解析的过程中是在pig线程中多线程并行进行的。每一个analyzer下面都初始化一个daq instance并调用acquire进行抓包并分析。每一个daq instance下面都有一个或多个网卡来获取数据。因为目的主要是介绍daq，所以怎么解析就不提了。从上图和上面的介绍就可以看得出来，一个snort下面有多个daq instance并行运行。每一个daq instance都会进行初始化操作，占用系统资源，获取网卡，抓包，调用callback，之间相互独立。并且是单线程的。 DAQ与DPDK如上面所介绍的。DAQ在设计的时候是单线程的。在本身的实现的几个模块中（Netmap,pcap等等）完全没有涉及到多线程的事情。在snort中的调用也是单线程并行调用的，相互之间各不影响。而Inter的DPDK在多线程方面则有限制。它所初始化的EAL层只能初始化一次。一个程序中只能运行一个dpdk主程序。所以就没有办法在snort中使用多线程。因为如果在snort中使用了多线程。那么实际上每个线程都会去尝试初始化dpdk的EAL。那么就会出错，导致最后只有一个线程能够成功初始化并启动。所以如果要想实现一个支持snort多线程的daq。就需要修改daq中api的逻辑。在实现中，利用线程id来绑定网卡。在daq的content中加入了一个nic-threadid的映射表。然后每个网卡都有一个独立的instance存储原本在daq_content中的信息。然后在线程调用daq相关函数的时候，都会先利用threadid来进行检索这个instance进行操作。通过这个方法就能够将dpdk中的各个网卡独立运行。 Github地址daq_dpdk基于的是dpdk16.04, daq2.1.0,snort 3.0 a04.使用方法在项目主页中。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"},{"name":"Snort","slug":"Snort","permalink":"https://nachtz.github.io/tags/Snort/"}]},{"title":"dpdk_ring剥离（单线程版）","date":"2016-06-17T10:19:59.000Z","path":"2016/06/17/dpdk_ring/","text":"DPDK_RING 剥离(sc)dpdk中的ring结构的原理在官方的doc中有。详细的介绍了单线程和多线程下的ring的结构的实现。其中线程安全的ring的出入队中没有用到锁，这个结构是比较巧妙的。此外，和一般的ring设计相比，dpdk的ring中减少了比较的次数和减法的次数。考虑了很多性能方面的东西。目前就剥离了单线程版的。代码如下： daq_ring.h12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef DAQ_RING_H#define DAQ_RING_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//#include &lt;pthread.h&gt;typedef struct _daq_ring&#123; // pthread_mutex_t mutex; int size; int mask; int cons_head; int cons_tail; int prod_head; int prod_tail; void * ring[0];&#125;;typedef struct _daq_ring daq_ring;//create a ring which can contain size's objects.daq_ring * daq_ring_create(int num);//fre a ring.int daq_ring_free(daq_ring * r);//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r);//see whether a ring is full.int daq_ring_isFull(daq_ring * r);//see the number of objects in ring now.int daq_ring_count(daq_ring * r);//see the size of a ring.int daq_ring_getSize(daq_ring *r);//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r);//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc);//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc);#endif//end of daq_ring.h -daq_ring.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include \"daq_ring.h\"/*typedef struct _daq_ring&#123; pthread_mutex_t mutex; unsigned int size; void * head; void * tail; void * memhead;&#125;daq_ring;*/daq_ring * daq_ring_create(int num)&#123; daq_ring * r = NULL; if(num &lt;=0)return NULL; r = (daq_ring *)malloc(sizeof(daq_ring) + num*sizeof(void*)); if(r == NULL)&#123; return NULL; &#125; r-&gt;size = num; r-&gt;mask = num-1; r-&gt;prod_head = r-&gt;prod_tail = r-&gt;cons_head = r-&gt;cons_tail = 0; // pthread_mutex_init(&amp;r-&gt;mutex,NULL); return r;&#125;//fre a ring.int daq_ring_free(daq_ring * r)&#123; free(r);&#125;//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r)&#123; return r-&gt;cons_tail == r-&gt;prod_tail;&#125;//see whether a ring is full.int daq_ring_isFull(daq_ring * r)&#123; return (((r-&gt;cons_tail - r-&gt;prod_tail -1)&amp;r-&gt;mask)==0);&#125;//see the number of objects in ring now.int daq_ring_count(daq_ring * r)&#123; return ((r-&gt;prod_tail - r-&gt;cons_tail)&amp;r-&gt;mask);&#125;//see the size of a ring.int daq_ring_getSize(daq_ring *r)&#123; return r-&gt;size;&#125;//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r)&#123; return ((r-&gt;cons_tail - r-&gt;prod_tail - 1) &amp; r-&gt;mask);&#125;//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc)&#123; int prod_head = r-&gt;prod_head; int cons_tail = r-&gt;cons_tail; int prod_next = prod_head +1; int mask = r-&gt;mask; int i ; int free = mask + cons_tail -prod_head; if(num &gt;free)&#123; if(free == 0)return 0; num = free; &#125; prod_next = prod_head +num; r-&gt;prod_head = prod_next; &#123; const int size = r-&gt;size; int idx = prod_head &amp; mask; if(idx + num &lt; size)&#123; for (i = 0; i &lt; (num &amp; ((~(unsigned)0x3))); i+=4, idx+=4) &#123; r-&gt;ring[idx] = obj_table[i]; r-&gt;ring[idx+1] = obj_table[i+1]; r-&gt;ring[idx+2] = obj_table[i+2]; r-&gt;ring[idx+3] = obj_table[i+3]; &#125; switch (num &amp; 0x3) &#123; case 3: r-&gt;ring[idx++] = obj_table[i++]; case 2: r-&gt;ring[idx++] = obj_table[i++]; case 1: r-&gt;ring[idx++] = obj_table[i++]; &#125; &#125;else&#123; for (i =0;idx&lt;size;++i,++idx) r-&gt;ring[idx] = obj_table[i]; for(idx = 0;i&lt;num;++i,++idx) r-&gt;ring[idx] = obj_table[i]; &#125; &#125; r-&gt;prod_tail = prod_next; return num;&#125;//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc)&#123; int cons_head,prod_tail; int cons_next,entries; int i; int mask = r-&gt;mask; cons_head = r-&gt;cons_head; prod_tail = r-&gt;prod_tail; entries = prod_tail - cons_head; if(num &gt; entries)&#123; if(entries == 0)return 0; num = entries; &#125; cons_next = cons_head + num; r -&gt; cons_head = cons_next; &#123; int idx = cons_head &amp; mask; int size = r-&gt; size; if (idx + num &lt; size) &#123; for (i = 0; i &lt; (num &amp; (~(unsigned)0x3)); i+=4, idx+=4) &#123; obj_table[i] = r-&gt;ring[idx]; obj_table[i+1] = r-&gt;ring[idx+1]; obj_table[i+2] = r-&gt;ring[idx+2]; obj_table[i+3] = r-&gt;ring[idx+3]; &#125; switch (num &amp; 0x3) &#123; case 3: obj_table[i++] = r-&gt;ring[idx++]; case 2: obj_table[i++] = r-&gt;ring[idx++]; case 1: obj_table[i++] = r-&gt;ring[idx++]; &#125; &#125; else &#123; for (i = 0; idx &lt; size; i++, idx++) obj_table[i] = r-&gt;ring[idx]; for (idx = 0; i &lt; num; i++, idx++) obj_table[i] = r-&gt;ring[idx]; &#125; &#125; r-&gt;cons_tail = cons_next; return num;&#125;void daq_ring_stat(daq_ring * r)&#123; printf(\"***********************************************\\n\"); printf(\"Daq_ring's size is %d\\n\",daq_ring_getSize(r)); printf(\"Daq_ring's objects now is %d.\\n\",daq_ring_count(r)); printf(\"Daq_ring's free space is %d\\n\",daq_ring_freeCount(r)); printf(\"Daq_ring is %s now.\\n\",daq_ring_isEmpty(r)?\"empty\":\"not empty\"); printf(\"Daq_ring is %s now.\\n\",daq_ring_isFull(r)?\"full\":\"not full\"); printf(\"***********************************************\\n\");&#125;void print_ptr(daq_ring *r)&#123; printf(\"r-&gt;cons:%p %p\\n\", r-&gt;cons_head, r-&gt;cons_tail); printf(\"r-&gt;prod:%p %p\\n\",r-&gt;prod_head,r-&gt;prod_tail); printf(\"r-&gt;ring[0]:%p\\n\",&amp;r-&gt;ring[0]); &#125;int test1()&#123; char * str[] = &#123; \"t1\",\"t2\",\"t3\",\"t4\",\"t5\",\"t6\",\"t7\",\"t8\",\"t9\",\"t10\",\"t11\",\"t12\",\"t13\" &#125;; void * ctx[12]; int i; for(i =0;i&lt;10;++i) printf(\"%s\\n\",str[i]); daq_ring * r = daq_ring_create(9); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(int i =0;i&lt;8;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r);print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(i =0;i&lt;10;++i) printf(\"%s\\n\",(char *)ctx[i]); return 0;&#125;int test2()&#123; int i; char * str[] = &#123; \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\", \"t10\", \"t11\", \"t12\", \"t13\", \"t14\", \"t15\", \"t16\", \"t17\" &#125;; void * ctx[18]; daq_ring * r = daq_ring_create(16); daq_ring_enqueue(r,str,14,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,4,1); for(i =0;i&lt;4;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,&amp;str[5],5,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,15,1); for(i =0;i&lt;15;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r);&#125;int main()&#123; test2(); return 0;&#125;","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]},{"title":"DPDK杂记","date":"2016-06-17T10:19:02.000Z","path":"2016/06/17/dpdk_note/","text":"DPDK编译动态库将common_linuxapp中的CONFIG_RTE_BUILD_SHARED_LIB和CONFIG_RTE_BUILD_COMBINE_LIBS都改为y，重新编译。将生成的lib文件拷贝到linux的lib中。（在dpdk16.04中，combine这个选项被取消了。邮件组中提到说是默认就是combine了。但是实际编译中发现不同的网卡驱动还是没有编译在一起。拷贝的时候都需要拷贝过去。）之后就是修改Makefile.将makefile中的1include $(RTE_SDK)/mk/rteextapp.mk 改为1include $(RTE_SDK)/mk/rte.extshared.mk 把binary name中的app改为1SHARED = yourname.so 最后再加上库：1LDLIBS += -L/home/nachtz/dpdk-2.2.0/x86_64-native-linuxapp-gcc/lib -ldpdk -lrt -lm -lgcc_s -ldl 就行了。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]}]