[{"title":"数据结构与算法","date":"2017-03-01T05:19:02.000Z","path":"2017/03/01/data_struct_and_ag/","text":"整理和自己总结的部分数据结构和算法。 数据结构队列特点是FIFO。是一种常见的数据结构。可用链表和数组实现。操作 | 链表实现复杂度 | 数组实现复杂度— | — | —出队 | 1 | n入队 | n | 1扩容 | n | n 出队时，链表只需要给出链头并将链头重新指向即可，而数组则需要进行一次全数组移动的操作。入队时，链表需要遍历一遍链表，数组则不需要。扩容时，链表是需要遍历一次，而数组需要进行一次拷贝。 树树的子树还是树；度：节点的子树个数；树的度：树中任意节点的度的最大值；兄弟：两节点的parent相同；层：根在第一层，以此类推；高度：叶子节点的高度为1，根节点高度最高；有序树：树中各个节点是有次序的；森林：多个树组成； 二叉树二叉树的数组存储下标公式：第i个节点的左右子节点是2i+1, 2i+2满二叉树的深度为k，节点数是2的k次方-1先序遍历：先访问根节点，再访问左节点，再访问右节点中序遍历：左-&gt;根-&gt;右后序遍历：左-&gt;右-&gt;根中序遍历+另外一种遍历可以还原一棵二叉树。 二叉查找树： 左子树的所有节点值都小于根节点值，右子树所有节点值都大于根节点值。 左右子树也为二叉查找树。 所有节点值都不重复。 先序遍历是递增序，后序是递减序。 插入和删除操作。 红黑树 (有点看不懂,先放着)某blog一种平衡二叉查找树。C++ stl 中set, multiset, map , multimap(muti允许内部有重复元素)用了红黑树。红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 节点是红色或黑色。 根节点是黑色。3 每个叶节点（NIL节点，空节点）是黑色的。4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 旋转旋转是为了让失去平衡的红黑树（比如插删操作后，左右子树的高度不一致了。）重新恢复平衡。如图： 左旋，如图所示（左-&gt;右），以x-&gt;y之间的链为“支轴”进行， 使y成为该新子树的根，x成为y的左孩子，而y的左孩子则成为x的右孩子。 重新着色旋转后红黑色颜色特性被破坏了。需要重新着色。 堆某blog也叫优先队列，是完全二叉树。大顶堆（小顶堆）是父节点大于（小于）两个子节点的值，且两个子节点也都是一个大顶堆（小顶堆）。堆的数组表示：下标从1开始。对一个节点t，他的父节点为t/2，左孩子节点是2t，右孩子节点2t+1.保持堆的性质（heapfy）：左右子树都必须已经是堆(这里，只有一个节点的树显然是堆)。将root 与left, right比较，最大的值与root交换，比如是right，然后递归调整右子树。数组转堆：数组长度为n，从堆的最后一个非叶子节点n/2的地方开始，往前进行heapfy操作。123456void BuildHeap(int A[],) &#123; int i; for(i = HEAP_SIZE(A)/2; i&gt;=1; i--) Heapify(A, i); &#125; 优先队列（priority queue）优先队列是一种基于堆实现的数据结构。其特性是队列中的元素是按照从大到小排列的。 pop操作：获取队列中的最大值 步骤有三步，时间复杂度为o(lg n)： 从堆中取堆顶元素，对应的是堆底层数据存储结构数组A[1]（注意，A[0]是不用留空的。） 将数组A最后一个元素A[n]放在A[1]的位置，同时将数组长度置为n-1. 对数组从上往下往下进行heapfy操作。 push 操作：往队列中加入一个数。步骤有两步，时间复杂度为o(lg n): 在数组A尾部放入这个树。 对该数组至下往上进行heapfy操作。12345678910void Insert(int A[], int i) &#123; //i为插入的值 int n=++HEAP_SIZE(A); A[n] = -99999;//小无穷 int p = n; while(p &gt;1 &amp;&amp; A[PARENT(p)] &lt; i) &#123; A[p] = A[PARENT(p)]; p = PARENT(p); &#125; A[p]=i; &#125; 栈某文库 FILO。懒得打字了。线性表的储存罢了。对栈的操作，感觉更像是一种特殊的约定。他们的操作更像是在线性的数组上认为的添加限制。即加入时只能加到数组头，移出时只能移除数组尾部。 另，计算机的堆区和栈区堆区和栈区实际上不属于数据结构与算法的范畴了，应该是操作系统的部分。但是名字一样在这也补一个。懒得提炼直接复制了。某blog一、预备知识—程序的内存分配一个由c/C++编译的程序占用的内存分为以下几个部分1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放5、程序代码区—存放函数体的二进制代码。 二、堆和栈的理论知识2.1申请方式stack:由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间heap:需要程序员自己申请，并指明大小，在c中malloc函数如p1 = (char )malloc(10);在C++中用new运算符如p2 = (char )malloc(10);但是注意p1、p2本身是在栈中的。 2.2申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 2.3申请大小的限制栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 2.4申请效率的比较：栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 2.5堆和栈中的存储内容栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 排序算法插入思路：在一个有序的序列中，插入一个新的数，让这个序列依然有序。插入排序是稳定的排序，即在一个序列中，如果有两个数相等，那么他们之间的前后顺序在排序后不变。复杂度： 一般情况o(n2)，最优情况排好序的情况o(n),最差情况o(n2)，数列为逆序。算法： 冒泡思想：通过两两交换，像水中的泡泡一样，小的先冒出来，大的后冒出来。是稳定排序。复杂度：o(n2)，没有最优或最差情况。算法： 选择思路：在数列中，每次选择一个最小的值，放到新排列数列的最后面。不稳定排序。复杂度：o(n2)算法： 归并思路：分治思想解决排序。是稳定排序。复杂度：o(n lgn)。伪代码：1234567mergeSort(A,i,j)&#123; if i &lt; j mid = (i+j)/2 mergeSort(A,i,mid) mergeSort(A, mid+1,j) merge(A,i,m,g)&#125; 其中，merge的操作就是将两个基本有序的数列合并到一起。这个过程需要额外的一个数组来做临时变量。算法： 快速基本是必考的排序。思路：利用分治的思想，将大问题化为两个小问题，然后再合并。首先在一个已排序的序列中，随便选择一个数。然后将比这个数大的放在这个数右边，小的放在左边。然后对这两个子区间再排序。是不稳定的排序。复杂度：o(nlgn) 没有最优情况，最差情况是每次选择都选择到了数组的最值，这个时候分区最不平衡。一般的实现上来讲，会发生在排序的数列是逆序或者所有数列都是相等的时候。解决方法是三值取中法。算法： 堆思路：利用最大堆和最小堆进行排序。将数组整理为堆，然后每次弹出堆顶即可。复杂度：o(nlg n) 基底思路：从个位到高位，对于每一位进行排序，而每一位的排序，都视为计数排序。是稳定的排序，需要额外的空间。例图：复杂度：o((n+k)d) 算法： 桶思路：先预筛选再进行排序。把一个大的复杂的数列先按大小范围把不同元素放到不同的桶里面。然后对不同桶里面的数进行排序。稳定排序，需要额外的空间。复杂度：最优情况是o(n)，这个时候所有的元素均匀分布到各个桶里面，而且桶内元素正好有序。最坏情况是全部元素都分到一个桶里面，为o(n2)或者o(nlg n)如果桶内排序用的是快排的话。算法： 计数思路：利用数组的下标进行统计的排序。这个算法速度快(o(n),基本上这种有一定使用条件的排序算法速度上都会优于通用的排序方法。)，需要额外的空间，不适用于有负数的排序和数组中含有特别大的数的数列。复杂度：o(n+k)，k为数列中最大的数。需要额外的空间复杂度。o(k)是不稳定的排序。本质上是先统计在根据统计还原。和原来的数组已经没有关系了。算法： 睡眠这是来搞笑的。= =构造n个线程，它们和这n个数一一对应。初始化后，线程们开始睡眠，等到对应的数那么多个时间单位后各自醒来，然后输出它对应的数。这样最小的数对应的线程最早醒来，这个数最早被输出。 算法补遗查找算法 二分查找思路：折办查找，元素必须是有序的才可以。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。复杂度: o(lg n)算法：1234567891011121314151617181920212223242526272829//二分查找（折半查找），版本1int BinarySearch1(int a[], int value, int n)&#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; &#125; return -1;&#125;//二分查找，递归版本int BinarySearch2(int a[], int value, int low, int high)&#123; int mid = low+(high-low)/2;//这种求mid的写法是为了防止溢出，因为high+low是有可能溢出的。 if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high);&#125; partition中位数这个算法是在乱序的数组中查找中位数的算法。利用快排关键字的查找方法a.随机选取一个关键字key，将序列二分；b.若关键字的下标大于N/2，则继续对序列的左半部分执行partition；c.若关键字的下标小于N/2，则继续对序列的右半部分执行partition；d.若关键字的下标等于N/2，则返回key。算法复杂度是o(nlg n)?. 基于流的中位数提炼一下就是利用大小堆来存储这个流的数。在存储的过程中，大堆保存中位数左边的数，小堆保存中位数右边的数。在拿到流中的数时，动态调整（在新到达的数，大堆顶，小堆顶三个数中比较，然后选则将新的数送到哪个堆中）。需要取中位数数时只要取两个堆顶即可。给一个数据流，找出中位数，由于数据流中的数据并不是有序的，所以我们首先应该想个方法让其有序。如果我们用vector来保存数据流的话，每进来一个新数据都要给数组排序，很不高效。所以之后想到用multiset这个数据结构，是有序保存数据的，但是它不能用下标直接访问元素，找中位数也不高效。这里用到的解法十分巧妙，我们使用大小堆来解决问题，其中大堆保存右半段较大的数字，小堆保存左半段较小的数组。这样整个数组就被中间分为两段了，由于堆的保存方式是由大到小，我们希望大堆里面的数据是从小到大，这样取第一个来计算中位数方便。我们用到一个小技巧，就是存到大堆里的数先取反再存，这样由大到小存下来的顺序就是实际上我们想要的从小到大的顺序。当大堆和小堆中的数字一样多时，我们取出大堆小堆的首元素求平均值，当小堆元素多时，取小堆首元素为中位数 最短路径迪杰斯特拉 动态规划不知道该怎么讲，丢个连接dp 蓄水池抽样介绍从一个长度未知或者很长的序列中随机抽取出k个元素，保证k个元素的输出是完全随机的。构造一个可以放置k个元素的蓄水池，将序列的前k个元素放入蓄水池类，然后从第k+1个元素开始，以k/n的概率来决定钙元素是否需要被替换到水池中。 实现伪代码如下：1234567Init : a reservoir with the size： k for i= k+1 to N M=random(1, i); if( M &lt; k) SWAP the Mth value and ith value end for 证明 对于第i个数(i&lt;k)，在前k步被选中的概率是1， 从第k+1步开始，i不被选中的概率为k/k+1,那么读到第n个数时， 第i个数(i&lt;k)被选中的概率 = 被选中的概率 以后每一步都不被换走的概率,即`1 k/k+1 * k+1/k+2 …n-1/n = k/n` 对于第j个数(j&gt;=k)被选中的概率为： 在他出现时被选中的概率 在他出现以后不被换走的概率,即:`k/j j /j+1 。。。n-1/n = k/n` 位运算看大佬 拉格朗日四平方和定理拉格朗日四平方和定理Leetcode 279 perfect squares四平方和定理说明每个正整数均可表示为4个整数的平方和。 任何形为4n+1的素数都能表示为两个平方数之和。用dp[i]表示i的正数组成情况时：dp[i*i] = 1;dp[i*i + a] = dp[a]+1;利用这个来进行dp递推公式的推导。 123456789101112131415161718192021class Solution &#123;public: int min(int a, int b)&#123; if (a&gt;b) return b; return a; &#125; int numSquares(int n) &#123; int *dp = new int[n+1]; for(int i =0;i!=n+1;++i)dp[i] = 4; for(int i =0;i*i&lt;=n;++i)&#123; dp[i*i] = 1; &#125; for(int a = 0;a!=n+1;++a)&#123; for(int b = 0;b*b&lt;=a;++b)&#123; dp[a] = min(dp[a],dp[a-b*b]+1); &#125; &#125; return dp[n]; &#125;&#125;; kmp和manacherkmp算法思想kmp算法的思想是利用额外的信息量来避免不必要的匹配。假设我们匹配两个串分别到了i,j时发现不匹配了。正常的算法是将计数器重新计算到匹配的开头加1.但是这么做就浪费了串0~i-1 和串0~j-1之间的串都相等的这个信息量。kmp的思路就是要利用这个额外的信息量将匹配的窗口尽量的滑动到最远。 额外的信息量额外的信息量是指前缀函数。比如对于字符串ABCDABD而言。其前缀函数的信息是： 表头 1 2 3 4 5 6 7 搜索词 A B C D A B D 部分匹配词 0 0 0 0 1 2 0 求取这个next的代码如下：1234567891011121314151617public int[] getNext(String b) &#123; int len=b.length(); int j=0; int next[]=new int[len+1];//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始 next[0]=next[1]=0; for(int i=1;i&lt;len;i++)//i表示字符串的下标，从0开始 &#123;//j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置 while(j&gt;0&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j]; if(b.charAt(i)==b.charAt(j))j++; next[i+1]=j; &#125; return next; &#125; 字符串匹配字符串匹配的过程和获取额外信息的函数是基本一致的。都是依照next[j]来进行（匹配失败时）下标的移动。1234567891011121314public void search(String original, String find, int next[]) &#123; int j = 0; for (int i = 0; i &lt; original.length(); i++) &#123; while (j &gt; 0 &amp;&amp; original.charAt(i) != find.charAt(j)) j = next[j]; if (original.charAt(i) == find.charAt(j)) j++; if (j == find.length()) &#123; System.out.println(\"find at position \" + (i - j)); System.out.println(original.subSequence(i - j + 1, i + 1)); j = next[j]; &#125; &#125; &#125; Reference manacher 回文子串介绍在o(n)的时空复杂度内，求出以每个字符为中心的最长回文有多长。这个算法可以求出包括奇数和偶数的回文串。算法的核心思想就是利用已经匹配的最右位置和对应的对称中心来跳过已经进行过的比较。 过程 在每两个字符中插入一个分隔符。这个分隔符在原文中没有出现，一般是用#. 然后用一个辅助数组P来记录以每个中心为最长回文传的信息。 123before : waaabwswfdafter : # w # a # a # a # b # w # s # w # f # d #P: 1 2 1 2 3 2 1 2 1 2 1 2 1 4 1 2 1 2 1 2 1 P[id]-1就是该回文子串在原串中的长度 在扫描的时候，线性的从左往右扫描。在扫描的时候，用mx在记录i在之前的回文串查找过程中，查找到的最右的位置，以及取到这个最右值时的字符位置id。 关键的比较： 12if (i &lt; mx) p[ i ] = min( p[ 2 * id - i ], mx - i ); 2*id-i求得是i关于id对称的点。这个对称点上的回文子串的长度在目前以及匹配到的结果中，和i点事一样的。（除非碰到了左边界或右边界） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;utility&gt; using namespace std; char s[1000]; char s_new[2000]; int p[2000]; int Init() &#123; int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) &#123; s_new[j++] = s[i]; s_new[j++] = '#'; &#125; s_new[j] = '\\0';//别忘了哦 return j;//返回s_new的长度 &#125; int Manacher() &#123; int len = Init();//取得新字符串长度并完成向s_new的转换 int maxLen = -1;//最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) &#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i);//需搞清楚上面那张图含义,mx,2 * id - i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]])//不需边界判断，因为左有'$',右有'\\0' p[i]++; if (mx &lt; i + p[i])//我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx) 这句代码，从而提高效率 &#123; id = i; mx = i + p[i]; &#125; maxLen = max(maxLen, p[i] - 1); &#125; return maxLen; &#125; int main() &#123; while (printf(\"请输入字符串：\\n\")) &#123; scanf(\"%s\", s); printf(\"最长回文长度为 %d\\n\\n\", Manacher()); &#125; return 0; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://nachtz.github.io/tags/Algorithm/"}]},{"title":"在OpenDayLight控制器上开发Bundle","date":"2017-01-08T05:24:31.000Z","path":"2017/01/08/SDN_opendaylight_dev_bundle/","text":"在OpenDayLight控制器上开发Bundle odl远端仓库把startup project删除了。这个教程已经不再适用了。基于OpendayLight官网上的这篇文档翻译修改而来：Developing Apps on the OpenDaylight controller 本文档适用于boron版本。其他版本不一定适用。 综述本文档旨在指导如何在ODL控制器上开发应用。本文档包含以下内容： 创建一个简单的示例程序Hello World； 启动ODL控制器； 在Hello World测试简单的Remote Procedure Call(RPC)。 基础环境本文档需要以下基础开发环境： Maven 3.1.1 或更新的版本 JDK 7/8 合适的Maven settings.xml。可以通过一下途径获得默认的OpenDaylight settings.xml 1cp -n ~/.m2/settings.xml&#123;,.orig&#125; ; \\wget -q -O - https://raw.githubusercontent.com/opendaylight/odlparent/stable/boron/settings.xml &gt; ~/.m2/settings.xml 在除Linux和Mac OS X以外的环境中，你需要修改上诉命令中maven的本地仓库地址~/.m2/repository 构建一个Example模块 按以下步骤构建： 从Maven远端仓库中拉取一个初始工程。（第一次拉取的时候需要一定的时间） 123mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype \\-DarchetypeRepository=https://nexus.opendaylight.org/content/repositories/public/ \\-DarchetypeCatalog=https://nexus.opendaylight.org/content/repositories/public/archetype-catalog.xml 在国内，由于墙的缘故，你可能需要设置代理才能较快的下载工程。设置代理的参数如下： 1-DsocksProxyHost=YourProxyHost -DsocksProxyPort=YourProxyPort 此外你还可以使用多线程编译，跳过生成文档，跳过测试来加快速度： 1-T 1C -D maven.javadoc.skip=true -DskipTests 使用如下值来初始化工程： 123456Define value for property 'groupId': : org.opendaylight.exampleDefine value for property 'artifactId': : exampleDefine value for property 'version': 1.0-SNAPSHOT: : 1.0.0-SNAPSHOTDefine value for property 'package': org.opendaylight.example: :Define value for property 'classPrefix': : $&#123;artifactId.substring(0,1).toUpperCase()&#125;$&#123;artifactId.substring(1)&#125;Define value for property 'copyright': : Copyright (c) 2015 Yoyodyne, Inc. 其中，version,package,classPrefix都会默认填写，直接回车就行。 完成步骤1,2后，可以看到一个example文件夹。可以看到如下目录结构。 123456789$&#123;artifactId&#125;/example/cd example/api/artifacts/features/impl/karaf/pom.xml 构建示例工程。 注意，这个可能需要耗费一定的时间，你可以使用1中提到的maven参数来提升编译速度。 1mvn clean install 启动ODL控制器。 123cd karaf/target/assembly/binls./karaf 等待直至启动完毕出现以下命令行。可能需要等一段时间，这个时间和你电脑配置有关。 1opendaylight-user@root&gt; 查看日志，确认example模块被正常加载。 1log:display | grep Example 关闭ODL控制器。 1shutdown -f 定义一个简单的`Hello World RPC 从maven远端仓库拉取初始工程。 123mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype \\ -DarchetypeRepository=http://nexus.opendaylight.org/content/repositories/opendaylight.release/ \\ -DarchetypeCatalog=http://nexus.opendaylight.org/content/repositories/opendaylight.release/archetype-catalog.xml 这里需要注意，原文中使用的是snapshot，而使用snapshot会出现无法编译通过的问题。本文中使用release版本且目前的maven远端仓库release版本是boron。 使用如下值来初始化工程： 123456Define value for property 'groupId': : org.opendaylight.helloDefine value for property 'artifactId': : helloDefine value for property 'version': 1.0-SNAPSHOT: : 1.0.0-SNAPSHOTDefine value for property 'package': org.opendaylight.hello: :Define value for property 'classPrefix': : $&#123;artifactId.substring(0,1).toUpperCase()&#125;$&#123;artifactId.substring(1)&#125;Define value for property 'copyright': : Copyright (c) 2015 Yoyodyne, Inc. 其中，version,package,classPrefix都会默认填写，直接回车就行。 查看hello工程。 12345678cd hello/ls -1apiartifactsfeaturesimplkarafpom.xml 构建Hello工程。 1mvn clean install 同样，可以利用之前提到的参数来提升编译构建速度。 启动ODL控制器。 123cd karaf/target/assembly/binls./karaf 等待直至启动完毕出现以下命令行。可能需要等一段时间，这个时间和你电脑配置有关。 1opendaylight-user@root&gt; 查看日志，确认Hello模块被正常加载。 1log:display | grep Hello 关闭ODL控制器。 1shutdown -f 返回到Hello目录： 1cd ../../../../ 可以通过查看Hello模块的实现来了解7中的日志从何而来，模块实现源文件路径如下： 1impl/src/main/java/org/opendaylight/hello/impl/HelloProvider.java 可以使用HelloProvider.onSessionInitiate方法来添加自己的实现。 1234@Overridepublic void onSessionInitiated(ProviderContext session) &#123; LOG.info(\"HelloProvider Session Initiated\");&#125; 添加一个简单的HelloWorld RPC API 修改YANG文件。 1vi api/src/main/yang/hello.yang 修改为如下文件，通过修改该文件来定义hello-world RPC： 1234567891011121314151617181920 module hello &#123; yang-version 1; namespace \"urn:opendaylight:params:xml:ns:yang:hello\"; prefix \"hello\"; revision \"2015-01-05\" &#123; description \"Initial revision of hello model\"; &#125; rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greating &#123; type string; &#125; &#125; &#125;&#125; 返回到hello/api目录并构建你的API: 12cd ../../../mvn clean install 实现HelloWorld RPC API 定义HelloService，该服务会被HelloWorldAPI调用。 1cd ../impl/src/main/java/org/opendaylight/hello/impl/ 创建HelloWorldImpl.java文件，添加如下代码： 1234567891011121314151617181920212223/** Copyright © 2016 Cisco Systems and others. All rights reserved.** This program and the accompanying materials are made available under the* terms of the Eclipse Public License v1.0 which accompanies this distribution,* and is available at http://www.eclipse.org/legal/epl-v10.html*/package org.opendaylight.hello.impl;import java.util.concurrent.Future;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloService;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloWorldInput;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloWorldOutput;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloWorldOutputBuilder;import org.opendaylight.yangtools.yang.common.RpcResult;import org.opendaylight.yangtools.yang.common.RpcResultBuilder;public class HelloWorldImpl implements HelloService &#123; @Override public Future&lt;RpcResult&lt;HelloWorldOutput&gt;&gt; helloWorld(HelloWorldInput input) &#123; HelloWorldOutputBuilder helloBuilder = new HelloWorldOutputBuilder(); helloBuilder.setGreating(\"Hello \" + input.getName()); return RpcResultBuilder.success(helloBuilder.build()).buildFuture(); &#125;&#125; 修改HelloProvider.java.注册在hello.yang中创建的RPC. 你可以自己添加自己想要的实现，或者直接按如下编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Copyright © 2016 Cisco Systems and others. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v1.0 which accompanies this distribution, * and is available at http://www.eclipse.org/legal/epl-v10.html */package org.opendaylight.hello.impl;import org.opendaylight.controller.md.sal.binding.api.DataBroker;import org.opendaylight.controller.sal.binding.api.RpcProviderRegistry;import org.opendaylight.controller.sal.binding.api.BindingAwareBroker.RpcRegistration;import org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.hello.rev150105.HelloService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloProvider &#123; private static final Logger LOG = LoggerFactory.getLogger(HelloProvider.class); private final DataBroker dataBroker; private final RpcProviderRegistry rpcProviderRegistry; private RpcRegistration&lt;HelloService&gt; serviceRegistration; public HelloProvider(final DataBroker dataBroker, RpcProviderRegistry rpcProviderRegistry) &#123; this.dataBroker = dataBroker; this.rpcProviderRegistry = rpcProviderRegistry; &#125; /** * Method called when the blueprint container is created. */ public void init() &#123; serviceRegistration = rpcProviderRegistry.addRpcImplementation(HelloService.class, new HelloWorldImpl()); LOG.info(\"HelloProvider Session Initiated\"); &#125; /** * Method called when the blueprint container is destroyed. */ public void close() &#123; serviceRegistration.close(); LOG.info(\"HelloProvider Closed\"); &#125;&#125; &gt; 这边需要注意：文件开头的版权声明不能去掉，否则无法通过Maven构建。此外，官网上的源文件有问题。本文档的源文件至少通过了本地编译。 此外，需要在BluePrint中注册你的RPC API.修改如下： 12cd hello/impl/src/main/resources/org/opendaylight/blueprintvi impl-blueprint.xml 修改为如下。 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- vi: set et smarttab sw=4 tabstop=4: --&gt;&lt;!--Copyright © 2016 Cisco Systems and others. All rights reserved.This program and the accompanying materials are made available under theterms of the Eclipse Public License v1.0 which accompanies this distribution,and is available at http://www.eclipse.org/legal/epl-v10.html--&gt;&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"xmlns:odl=\"http://opendaylight.org/xmlns/blueprint/v1.0.0\"odl:use-default-for-reference-types=\"true\"&gt; &lt;reference id=\"dataBroker\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\" odl:type=\"default\" /&gt;&lt;reference id=\"rpcRegistry\" interface=\"org.opendaylight.controller.sal.binding.api.RpcProviderRegistry\" /&gt;&lt;bean id=\"provider\" class=\"org.opendaylight.hello.impl.HelloProvider\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;argument ref=\"dataBroker\" /&gt; &lt;argument ref=\"rpcRegistry\" /&gt;&lt;/bean&gt;&lt;/blueprint&gt; &gt; 这个文档中添加了`rpcRegistry`。需要注意&lt;?xml&gt;前不能有空格。 然后回到hello/impl目录下编译。 1mvn clean install 回到hello目录下编译。 1mvn clean install 通过REST来测试hello-world RPC 有很多方式可以测试RPC, 比如以下两种。 通过HTTP使用ODL控制器自带的API Explorer 使用浏览器的REST 客户端 通过HTTP使用ODL控制器自带的API Explorer 使用浏览器进入 apidoc UI&lt;http://localhost:8181/apidoc/explorer/index.html&gt; 。 TIP: localhost是你ODL控制器的IP地址或者Hostname。 选择 12hello(2015-01-05) 选择 12POST /operations/hello:hello-world 在框内填写如下值 12&#123;\"hello:input\": &#123; \"name\":\"Your Name\"&#125;&#125; 点击按钮. 输入 username 和 password, 默认是admin/admin. 返回的Response body应该为： 123456&#123; \"output\": &#123; \"greating\": \"Hello Your Name\" &#125;&#125; 使用浏览器的REST 客户端 可以使用火狐浏览器的 RESTClient或者Chrome的Restlet Client。 1POST: http://192.168.1.43:8181/restconf/operations/hello:hello-world Header: ``` application/json ``` Body: {&quot;input&quot;: { &quot;name&quot;: &quot;Andrew&quot; } } TroubleshootingIf you get a response code 501 while attempting to POST/operations/hello:hello-world, check the file: HelloProvider.java andmake sure the helloService member is being set. By not invoking“session.addRpcImplementation()” the REST API will be unable to map/operations/hello:hello-world url to HelloWorldImpl. 这个应该碰不到了。所以就不翻译了。","tags":[{"name":"SDN","slug":"SDN","permalink":"https://nachtz.github.io/tags/SDN/"}]},{"title":"Smarking Algorithm Contest 3","date":"2016-11-06T06:37:31.000Z","path":"2016/11/06/Smarking Algorithm Contest 3/","text":"1. 453. Minimum Moves to Equal Array ElementsGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.Ex:12345678910Input:[1,2,3]Output:3Explanation:Only three moves are needed (remember each move increments two elements):[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 给一个长度为n的非空数组，将这个数组中的其中n-1个元素都+1，称为一次操作。求出将这个数组所有元素都变为相同大小的操作的次数。解法：12345678910111213141516func minMoves(nums []int) int &#123; if len(nums) &lt;= 1&#123; return 0 &#125; sum,min,max := nums[0],nums[0],nums[0] for i:=1;i&lt;len(nums);i++&#123; sum += nums[i] if min &gt; nums[i]&#123; min = nums[i] &#125; if max &lt; nums[i]&#123; max = nums[i] &#125; &#125; return sum - len(nums)*min&#125; 2. 447. Number of BoomerangsGiven n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).Ex:12345678Input:[[0,0],[1,0],[2,0]]Output:2Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 给定平面内的坐标。求出这些坐标中，一个点到另外两个点距离相同的组合。这题只要求出每个坐标到其他坐标的距离。然后再遍历就行了。 1234567891011121314151617181920212223242526272829303132func pow(t int) int&#123; return t*t&#125;func numberOfBoomerangs(points [][]int) int &#123; if len(points) &lt;3&#123; return 0 &#125; dis := make([][]int,len(points)) for i:=0;i&lt;len(points);i++&#123; dis[i] = make([]int,len(points)) &#125; for i:=0;i&lt;len(points);i++&#123; for j:=i+1;j&lt;len(points);j++&#123; t := pow(points[i][0] - points[j][0])+pow(points[i][1] - points[j][1]) dis[i][j],dis[j][i] = t,t &#125; &#125; count := 0 for i:=0;i&lt;len(points);i++&#123; for j:=0;j&lt;len(points);j++&#123; if j == i&#123; continue &#125; for k := j+1;k&lt;len(points);k++&#123; if dis[i][j] == dis[i][k]&#123; count +=2 &#125; &#125; &#125; &#125; return count&#125; 3. 452. Minimum Number of Arrows to Burst BalloonsThere are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.Ex:12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 这题把一堆乱七八糟的背景剥开后，题目实际上是这样的：给定一组区间，然后要你给出长度最小的一组数，这组数中所有的点都在区间内而且没有区间被遗漏。用贪心算法就可以做。将区间按起点从小到大排列。然后每一次都选一个点，能够尽量的覆盖到最多的区间。直到不能覆盖为止。依次取点，直到区间都有点落在上面。1234567891011121314151617181920212223242526272829303132333435363738394041type ranges [][]int func(r ranges)Len() int&#123; return len(r)&#125;func(r ranges)Less(i,j int)bool&#123; if r[i][0] != r[j][0]&#123; return r[i][0]&lt;r[j][0] &#125; return r[i][1]&lt;r[j][1]&#125;func (r ranges)Swap(i,j int)&#123; r[i][0],r[j][0] = r[j][0],r[i][0] r[j][1],r[i][1] = r[i][1],r[j][1]&#125;func findMinArrowShots(points [][]int) int &#123; p := ranges(points) sort.Sort(p) count := 0 for i:=0;i&lt;len(p);i++&#123; count ++ j := i+1 at := p[i][1] for j = i+1;j&lt;len(p) ;j++&#123; if p[j][0]&gt;at&#123; i = j-1 break &#125; if p[j][1] &lt; at&#123; at = p[j][1] &#125; &#125; if j == len(p)&#123; break &#125; &#125; return count&#125; 4. 446. Arithmetic Slices II - SubsequenceA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, …, Pk) such that 0 ≤ P0 &lt; P1 &lt; … &lt; Pk &lt; N. A subsequence slice (P0, P1, …, Pk) of array A is called arithmetic if the sequence A[P0], A[P1], …, A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2. The function should return the number of arithmetic subsequence slices in the array A. Ex:12345678910111213Input: [2, 4, 6, 8, 10]Output: 7Explanation:All arithmetic subsequence slices are:[2,4,6][4,6,8][6,8,10][2,4,6,8][4,6,8,10][2,4,6,8,10][2,6,10] 这题试了下DFS会超时，用DP做会MLE。最后没做出来。给个别人的代码：123456789101112131415161718192021222324class Solution(object): def numberOfArithmeticSlices(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" ans=0 dp = [] for i in range(len(A)): a=A[i] dp.append(&#123;&#125;) for j in range(i): b=A[j] d=a-b if d in dp[j]: v=1+dp[j][d] else: v=1 if d in dp[i]: dp[i][d]=dp[i][d]+v else: dp[i][d]=v ans += sum([dp[i][x] for x in dp[i]]) - i return ans","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"Smarking Algorithm Contest 2","date":"2016-10-30T04:21:31.000Z","path":"2016/10/30/Smarking Algorithm Contest 2/","text":"435. Non-overlapping IntervalsGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note: You may assume the interval’s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders “touching” but they don’t overlap each other. 给定一组区间，你可以移除一些区间让这组区间互不重叠。 做法是： 首先将区间按照起点大小排序。 将区间中所有完全覆盖其他区间的区间移除掉。 在剩下的区间中，如果有区间，和它之前的区间有重叠，就移除它。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859type arrI []Intervalfunc (a arrI)Len() int&#123; return len(a)&#125;func (a arrI)Less(i,j int) bool&#123; if a[i].Start!=a[j].Start&#123; return a[i].Start&lt;a[j].Start &#125; return a[i].End&gt;=a[j].End&#125;func (a arrI)Swap(i,j int)&#123; a[i],a[j] = a[j],a[i]&#125;func eraseOverlapIntervals(intervals []Interval) int &#123; if len(intervals) &lt;= 1&#123; return 0 &#125; tmp := arrI(intervals) sort.Sort(tmp) res := tmp[0] count :=0 ret := []Interval&#123;&#125; for i:=0;i&lt;len(tmp);i++&#123; flag := false if len(ret)&gt;0 &amp;&amp; tmp[i].Start &lt;= ret[len(ret)-1].Start&#123; flag = true count ++ &#125;else&#123; for j:=i+1;j&lt;len(tmp);j++&#123; if tmp[i].End &lt;= tmp[j].Start&#123; break &#125; if tmp[i].End &gt;= tmp[j].End&#123; flag = true count ++ break &#125; &#125; &#125; if !flag&#123; ret = append(ret,tmp[i]) &#125; &#125; if len(ret) == 0&#123; return count &#125; res =ret[0] for i:=1;i&lt;len(ret);i++&#123; if ret[i].Start &gt;= res.End&#123; res = ret[i] &#125;else&#123; count ++ &#125; &#125; return count&#125; 436. Find Right IntervalGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i. For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note: You may assume the interval’s end point is always bigger than its start point. You may assume none of these intervals have the same start point.给定一组区间，对于每一个区间，如果有其他区间的起点大于等于这个区间的终点，那么就称这个区间有右区间。找出最近的右区间的下标。没有右区间则该区间的最小右区间为-1。 这题直接用o(n*n)的算法就能过。即一个个找右区间。 123456789101112131415161718192021func findRightInterval(intervals []Interval) []int &#123; ret := make([]int,len(intervals)) for i:=0;i&lt;len(intervals);i++&#123; min := i for j:=0;j&lt;len(intervals);j++&#123; if j == i&#123; continue &#125; if intervals[j].Start &gt;= intervals[i].End&#123; if min == i || intervals[j].Start &lt; intervals[min].Start&#123; min = j &#125; &#125; &#125; if min == i&#123; min = -1 &#125; ret[i] = min &#125; return ret&#125; 441. Arranging CoinsYou have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. 水题，没啥好说的。12345678func arrangeCoins(n int) int &#123; idx :=1; for (n&gt;=idx)&#123; n -=idx idx ++ &#125; return idx-1&#125; 444. Sequence ReconstructionCheck whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 10^4. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence. link没做出来，贴个别人的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: bool sequenceReconstruction(vector&lt;int&gt;&amp; org, vector&lt;vector&lt;int&gt;&gt;&amp; seqs) &#123; int n = org.size(); vector&lt;int&gt; to(n), in(n); vector&lt;bool&gt; vis(n); vector&lt;vector&lt;int&gt;&gt; adj(n); int k = 0; for (auto &amp;x : org) &#123; x--; to[x] = k++; &#125; for (auto &amp;vec : seqs) &#123; for (auto &amp;c : vec) &#123; c--; if (c &lt; 0 || c &gt;= n) &#123; return false; &#125; vis[to[c]] = true; &#125; for (int i = 1; i &lt; vec.size(); i++) &#123; auto x = to[vec[i - 1]], y = to[vec[i]]; adj[x].push_back(y); in[y]++; if (x &gt; y) &#123; return false; &#125; &#125; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i]) &#123; return false; &#125; if (!in[i]) &#123; q.push(i); &#125; &#125; vector&lt;int&gt; sorted; while (!q.empty()) &#123; if (q.size() &gt; 1) &#123; return false; &#125; auto s = q.front(); q.pop(); sorted.push_back(s); for (auto v : adj[s]) &#123; if (!--in[v]) &#123; q.push(v); &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i != sorted[i]) &#123; return false; &#125; &#125; return true; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"Leetcode第十周周赛Smarking Algorithm Contest","date":"2016-10-23T06:37:31.000Z","path":"2016/10/23/leetcode_weekly_contest10/","text":"437. Path Sum IIIYou are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 给你个树，求出所有符合路径上的节点的值的和等于给定值这个条件的路径的个数。路径要求是自上而下，但是不要求从根出发，也不要求以叶子节点作为结尾。挂在这道题上面了。给个别人的解法：将路径分为两种走法，每个节点都有两种走法。第一种情况是以这个节点为起点，开始出发。第二种是继承之前的走法接着走下去。12345678910111213141516171819202122232425262728var res intfunc go2(root *TreeNode, need int)&#123; if root == nil&#123; return &#125; if need == 0&#123; res ++ &#125; if root.Left != nil&#123; go2(root.Left,need-root.Left.Val) &#125; if root.Right != nil&#123; go2(root.Right,need-root.Right.Val) &#125;&#125;func go1(root * TreeNode, need int)&#123; if root == nil&#123; return &#125; go2(root,need-root.Val) go1(root.Left,need) go1(root.Right,need)&#125;func pathSum(root *TreeNode, sum int) int &#123; res = 0 go1(root, sum) return res&#125; 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter.Example 1:123456789Input:s: \"cbaebabacd\" p: \"abc\"Output:[0, 6]Explanation:The substring with start index = 0 is \"cba\", which is an anagram of \"abc\".The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2:12345678910Input:s: \"abab\" p: \"ab\"Output:[0, 1, 2]Explanation:The substring with start index = 0 is \"ab\", which is an anagram of \"ab\".The substring with start index = 1 is \"ba\", which is an anagram of \"ab\".The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". 给定两个字符串s,p，求出p的所有变形（包括自己）在s中的起点。解法是统计p中的词频，然后统计s中i到i+len(p)中的字符串的词频。相比较，如果相等则说明命中了。123456789101112131415161718192021222324252627282930313233func check(a,b,c [26]int) bool&#123; for i:=0;i&lt;26;i++&#123; if a[i]-b[i] != c[i]&#123; return false &#125; &#125; return true&#125;func findAnagrams(s string, p string) []int &#123; if len(s)&lt;len(p)&#123; return []int&#123;&#125; &#125; ret := []int&#123;&#125; start, end, mark := [26]int&#123;&#125;,[26]int&#123;&#125;,[26]int&#123;&#125; for i:=0;i&lt;len(p);i++&#123; mark[p[i]-'a'] ++ &#125; for i:=0;i&lt;len(p);i++&#123; end[s[i]-'a'] ++ &#125; if check(end,start,mark)&#123; ret = append(ret,0) &#125; for i:=len(p);i&lt;len(s);i++&#123; start[s[i-len(p)]-'a'] ++ end[s[i]-'a']++ if check(end,start,mark)&#123; ret = append(ret,i-len(p)+1) &#125; &#125; return ret&#125; 439. Ternary Expression ParserGiven a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively). Note: The length of the given string is ≤ 10000. Each number will contain only one digit. The conditional expressions group right-to-left (as usual in most languages). The condition will always be either T or F. That is, the condition will never be a digit. The result of the expression will always evaluate to either a digit 0-9, T or F.Example 1:123Input: \"T?2:3\"Output: \"2\"Explanation: If true, then result is 2; otherwise result is 3. Example 2:1234567891011121314Input: \"F?1:T?4:5\"Output: \"4\"Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: \"(F ? 1 : (T ? 4 : 5))\" \"(F ? 1 : (T ? 4 : 5))\" -&gt; \"(F ? 1 : 4)\" or -&gt; \"(T ? 4 : 5)\" -&gt; \"4\" -&gt; \"4\"``` 就是C语言中常见的`?:`语句。这题可以利用栈来做，也可以利用递归来做，应该也可以用正则表达式来做。下面是递归的做法： func parseTernary(e string) string { if e[0] != ‘T’ &amp;&amp; e[0]!=’F’{ return e } c1,c2,i := 0,0,1 for i=1;i","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 9 第九周周赛","date":"2016-10-16T06:11:31.000Z","path":"2016/10/16/leetcode_weekly_contest9/","text":"422. Valid Word SquareGiven a sequence of words, check whether it forms a valid word square. A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns).Note: 1. The number of words given is at least 1 and does not exceed 500. 2. Word length will be at least 1 and does not exceed 500. 3. Each word contains only lowercase English alphabet a-z. 大致就是讲给定一组string数组，判断string数组是不是符合要求。要求方块横着读和竖着读是一样的。直接判断就行了。golang AC代码：123456789101112131415161718func validWordSquare(words []string) bool &#123; str := \"\" for i:=0 ;i&lt; len(words);i++&#123; str = \"\" for j:=0;j&lt;len(words);j++&#123; if i &lt; len(words[j])&#123; str += string(words[j][i]) &#125;else&#123; break &#125; &#125; if str != words[i]&#123; return false &#125; &#125; return true&#125; 423. Reconstruct Original Digits from EnglishGiven a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note: Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as “abc” or “zerone” are not permitted. Input length is less than 50,000. 给一串乱序的字母序列，求这个字母序列重组之后所代表的数字串。比如：123Input: \"owoztneoer\"Output: \"012\" 题目中说给出的字母序列都是必定合法而且唯一的。 这题主要是根据0-9的英文中独占的字母来进行判断的。判断的顺序如下： 数字 英文 字母 0 zero z 6 six s 2 two w 7 seven s 4 four u 5 five v 1 one o 9 nine n 8 eight i 3 three t 从表的第一项开始，我们首先可以通过z的个数确定0的个数，然后通过s确定6的个数。依次类推。需要注意的是9的个数是n的个数的一半。最后就能得到乱序序列的原来的数字组合了。golang AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980func originalDigits(s string) string &#123; nums := []string&#123;\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"&#125; var count [10]int var acount [26]int for i:=0;i&lt;len(s);i++&#123; acount[int(s[i]-'a')] ++ &#125; if acount[25]&gt;0&#123; str := nums[0] count[0] = acount[25] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[0] &#125; &#125; if (acount[int('x'-'a')]&gt;0)&#123; str := nums[6] count[6] = acount[int('x'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[6] &#125; &#125; if (acount[int('w'-'a')]&gt;0)&#123; str := nums[2] count[2] = acount[int('w'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[2] &#125; &#125; if (acount[int('s'-'a')]&gt;0)&#123; str := nums[7] count[7] = acount[int('s'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[7] &#125; &#125; if (acount[int('u'-'a')]&gt;0)&#123; str := nums[4] count[4] = acount[int('u'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[4] &#125; &#125; if (acount[int('v'-'a')]&gt;0)&#123; str := nums[5] count[5] = acount[int('v'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[5] &#125; &#125; if (acount[int('o'-'a')]&gt;0)&#123; str := nums[1] count[1] = acount[int('o'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[1] &#125; &#125; if (acount[int('n'-'a')]&gt;0)&#123; str := nums[9] count[9] = acount[int('n'-'a')]/2 for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[9] &#125; &#125; if (acount[int('i'-'a')]&gt;0)&#123; str := nums[8] count[8] = acount[int('i'-'a')] for i:=0;i&lt;len(str);i++&#123; acount[int(str[i]-'a')] -= count[8] &#125; &#125; count[3] = acount[int('r'-'a')] str := \"\" for i:=0;i&lt;=9;i++&#123; for j:=0;j&lt;count[i];j++&#123; str += string(i+'0') &#125; &#125; return str&#125; 424. Longest Repeating Character ReplacementGiven a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.给定一串仅由大写字母组成的字符串，和一个数字k。假定这个字符串最多有k个字母能被替换成其他字母。求这个替换的过程中，最长的连续重复序列的长度。这道题可以用枚举法，先假设以求最长的连续的A,那么在整个序列中，把不是A的点都标出来。然后看看把这些点中的某K个换成A。求出这个换的过程中的最长长度。算法复杂度是o(n).AC golang代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func characterReplacement(s string, k int) int &#123; dp := make([]int,len(s)+1) var ch [26]bool max := 0 if k == 0&#123; length := 1 for i :=1;i&lt;len(s);i++&#123; if s[i-1] == s[i]&#123; length ++ &#125;else&#123; if max &lt; length&#123; max = length &#125; length = 1 &#125; &#125; if max &lt; length&#123; max = length &#125; return max; &#125; //length := 0 for i :=0;i&lt;len(s);i++&#123; ch[s[i]-'A'] = true &#125; for i :=0;i&lt;26;i++&#123; if ch[i] == false&#123; continue &#125; c := 'A' + i // if c == 75&#123; // fmt.Println(\"break\") // &#125; idx :=0 for j:=0;j&lt;len(s);j++&#123; if int(s[j])!=c&#123; dp[idx] = j idx++ //else&#123; // fmt.Print(j,\" \") &#125; &#125; //fmt.Println(\"|\",c) if idx &lt;= k&#123; return len(s) &#125; if max &lt; dp[k]&#123; max = dp[k] &#125; for j:= k+1;j &lt;idx;j++&#123; if dp[j] - dp[j-k-1] - 1 &gt;= max&#123; max = dp[j] - dp[j-k-1] - 1 //fmt.Println(c) &#125; &#125; &#125; return max&#125; 425 Word Squares没做出来，贴一个别人的python代码，用了trie树加dfs：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution(object): def wordSquares(self, words): \"\"\" :type words: List[str] :rtype: List[List[str]] \"\"\" self.l = len(words[0]) self.trie = self.build(words) self.res = [] for word in words: self.dfs(words, self.trie, [word]) return self.res def dfs(self, words, trie, lst): if len(lst) == self.l: self.res.append(lst) return prefix = '' for i in range(len(lst)): prefix += lst[i][len(lst)] for s in self.get(trie, prefix): self.dfs(words, trie, lst + [s]) def build(self, words): trie = &#123;&#125; for word in words: t = trie for c in word: if c not in t: t[c] = &#123;&#125; t = t[c] t['#'] = '#' return trie def get(self, trie, prefix): res = [] t = trie for c in prefix: if c not in t: return res t = t[c] for s in self.getall(t): res.append(prefix + s) return res def getall(self, t): res = [] if '#' in t: return [''] for c in t: if c != '#': for s in self.getall(t[c]): res.append(c + s) return res","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"在Docker中运行DPDK","date":"2016-10-16T04:37:31.000Z","path":"2016/10/16/dpdk_docker/","text":"版本Docker：1.12.1DPDK:16.07 Docker的安装在Ubuntu中docker的安装还是很简单的。参考官方文档^1就行了。需要注意的是只能在64位，linux版本号不低于3.11.0-15-generic的发行版上运行。所以在OpenVZ的VPS上不能运行。 制造DPDK的Docker镜像这边主要参考的是网上的一篇博客^1和红帽的Github[^2]来写Dockerfile的。Dockerfile如下：12345678910111213141516171819FROM ubuntuMAINTAINER NachtZ&lt;nachtz@outlook.com&gt;LABEL RUN docker run -it --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev --name NAME -e NAME=NAME -e IMAGE=IMAGE IMAGE&quot;# Setup yum repos, or use subscription-manager# Install DPDK support packages.RUN apt-get update &amp;&amp; apt-get install -y libpcap-dev wget xz-utils gcc automake autoconf libtool make # Build DPDK and pktgen-dpdk for x86_64-native-linuxapp-gcc.WORKDIR /rootCOPY ./build_dpdk.sh /root/build_dpdk.shCOPY ./dpdk-profile.sh /etc/profile.d/#RUN /root/build_dpdk.sh# Defaults to a bash shell, you could put your DPDK-based application here.CMD [&quot;/bin/bash&quot;] 这个Dockerfile的注解如下：FROM ubuntu：说明该镜像的源镜像是Ubuntu。MAINTAINER NachtZ&lt;nachtz@outlook.com&gt;:介绍镜像的作者。 LABEL RUN docker run -it --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev --name NAME -e NAME=NAME -e· IMAGE=IMAGE IMAGE&quot;: 镜像的标签。 RUN apt-get update &amp;&amp; apt-get install -y libpcap-dev wget xz-utils gcc automake autoconf libtool make：安装DPDK所需要的依赖程序，因为在Docker中的系统都是比较精简的，所以很多程序都需要自己安装。 123WORKDIR /rootCOPY ./build_dpdk.sh /root/build_dpdk.shCOPY ./dpdk-profile.sh /etc/profile.d/ 上面这段话是把Dockerfile同目录下./build_dpdk.sh,./dpdk-profile.sh拷贝到镜像里面去。 CMD [&quot;/bin/bash&quot;]:指定动作是打开一个bash。 到此为止，一个可以用来安装DPDK的镜像就完成了。接下来就是打开它。 在Docker中安装DPDK在shell中运行：docker run -it --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev xxx（最后的xxx表示的是之前的镜像的名字）在运行这个之前，需要将宿主机的DPDK环境都配置好。比如hugepage，以及转载好DPDK驱动的端口。之后运行docker run， --privileged -v /sys/bus/pci/devices:/sys/bus/pci/devices -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node 这段话的意思就是给Docker容器权限来使用宿主机的端口，hugepage等。 之后我们进入到Docker的容器中。在容器的root目录下可以看到之前拷贝的./build_dpdk.sh。内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/bin/bash################################################################################## build_dpdk.sh## - Build DPDK and pktgen-dpdk for ## Usage: Adjust variables below before running, if necessary.## MAINTAINER: jeder@redhat.com################################################################################################################################################################### Define Global Variables and Functions################################################################################URL=http://fast.dpdk.org/rel/dpdk-16.04.tar.xzBASEDIR=/rootVERSION=16.04PACKAGE=dpdkDPDKROOT=$BASEDIR/$PACKAGE-$VERSIONCONFIG=x86_64-native-linuxapp-gcc# Download/Build DPDKcd $BASEDIRwget $URLtar -xf $PACKAGE-$VERSION.tar.xzcd $DPDKROOT sed -i 's/CONFIG_RTE_EAL_IGB_UIO=y/CONFIG_RTE_EAL_IGB_UIO=n/' $&#123;DPDKROOT&#125;/config/common_linuxapp \\ &amp;&amp; sed -i 's/CONFIG_RTE_LIBRTE_KNI=y/CONFIG_RTE_LIBRTE_KNI=n/' $&#123;DPDKROOT&#125;/config/common_linuxapp \\ &amp;&amp; sed -i 's/CONFIG_RTE_KNI_KMOD=y/CONFIG_RTE_KNI_KMOD=n/' $&#123;DPDKROOT&#125;/config/common_linuxapp # don't build unnecessary stuff, can be reversed in dpdk_config.shsed -i 's/CONFIG_RTE_APP_TEST=y/CONFIG_RTE_APP_TEST=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_TEST_PMD=y/CONFIG_RTE_TEST_PMD=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_EAL_IGB_UIO=y/CONFIG_RTE_EAL_IGB_UIO=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_LIBRTE_IGB_PMD=y/CONFIG_RTE_LIBRTE_IGB_PMD=n/' $&#123;DPDKROOT&#125;/config/common_base \\ &amp;&amp; sed -i 's/CONFIG_RTE_LIBRTE_IXGBE_PMD=y/CONFIG_RTE_LIBRTE_IXGBE_PMD=n/' $&#123;DPDKROOT&#125;/config/common_base \\make config T=$CONFIGsed -ri 's,(PMD_PCAP=).*,\\1y,' build/.configmake config T=$CONFIG install 这个文档来自^3。我依照DPDK 16.04中的文档和博客[^2]来改造的。在博客[^2]中提到： One thing that is important is to not rely on kernel headers; doing so would be seriously non portable. The uio and igb_uio kernel modules have to be built and installed by the host that will run the DPDK container. Therefore, we configure the SDK to not compile kernel modules, and therefore not require installing kernel headers on the build system. 就是说在Docker中，用到的网卡驱动是宿主机的驱动，所以不需要编译网卡内核驱动。在./build_dpdk.sh中，的两行sed语句就是在修改编译配置。 手动运行完./build_dpdk.sh之后，就可以正常编译运行DPDK的程序了。比如可以：12345$:export RTE_SDK=/root/dpdk-16.04$:export RTE_TARGET=x86_64-native-linuxapp-gcc$:cd dpdk-16.04/example/helloworld$:make$:./build/helloworld 就可以看到helloworld正常的运行了。 Github这是修改完成之后的Docker的Dockerfile和两个sh文件。NachtZ/docker-dpdk 参考资料 Jason的博客[^2] Redhat的dpdk_docker^3 Reference[^2]:Jason 的博客","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"},{"name":"Docker","slug":"Docker","permalink":"https://nachtz.github.io/tags/Docker/"}]},{"title":"LeetCode Weekly Contest 8 第八周周赛","date":"2016-10-09T06:37:31.000Z","path":"2016/10/09/leetcode_weekly_contest8/","text":"不知为何生成该博客会出现内存溢出问题。贴个其他地方的链接。LeetCode Weekly Contest 8 第八周周赛","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 6 第六周周赛","date":"2016-09-25T06:08:49.000Z","path":"2016/09/25/leetcode_weekly_contest6/","text":"404. Sum of Left Leaves不解释123456789101112131415161718func isLeaf(root * TreeNode) bool&#123; if root == nil || root.Left!=nil || root.Right!=nil&#123; return false &#125; return true;&#125;func sumOfLeftLeaves(root *TreeNode) int &#123; res := 0 if root != nil&#123; if isLeaf(root.Left)&#123; res += root.Left.Val &#125;else&#123; res += sumOfLeftLeaves(root.Left) &#125; res += sumOfLeftLeaves(root.Right) &#125; return res&#125; 405. Convert a Number to Hexadecimal常规的10进制转16进制。负数的转换需要先转为补码再计算。注意用long long int 防止溢出。12345678910111213141516171819202122class Solution &#123;public: string toHex(int num) &#123; string a[] = &#123; \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" &#125;; string res; if (num == 0)&#123; return \"0\"; &#125; long long int t; if (num &lt;0)&#123; t = unsigned(num); &#125; else&#123; t = num; &#125; while (t&gt;0)&#123; res = a[t % 16] + res; t /= 16; &#125; return res; &#125;&#125;; 406. Queue Reconstruction by Heighto(n*n)的复杂度。1.将人排序，以前置比他高的人数大小排列，相等的时候按照高度从低到高。2.取排列完第一位，将其取出队列。然后更新下排列中的人情况。即将比他矮的人中，front的人数-1。3.重复操作1，2直到队列中的人都被取出。4.还原队列中的front的情况。因为在第二步中，front的情况会被改写，所以需要恢复。12345678910111213141516171819202122232425262728293031323334353637383940414243type P [][]int func(p P) Len()int&#123; return len(p)&#125;func(p P)Swap(i,j int)&#123; p[i][0],p[i][1],p[j][0],p[j][1] = p[j][0],p[j][1],p[i][0],p[i][1]&#125;func (p P)Less(i,j int)bool&#123; if p[i][1]!=p[j][1]&#123; return p[i][1] &lt; p[j][1] &#125; return p[i][0] &lt; p[j][0]&#125;//1.sort//2.取当前队列func reconstructQueue(people [][]int) [][]int &#123; res := make([][]int,len(people)) for i:=0;i&lt;len(res);i++&#123; res[i] = make([]int,2) &#125; n := len(people) for i:=0;i&lt;n;i++&#123; sort.Sort(P(people)) res[i][0],res[i][1] = people[0][0],people[0][1] for j:=1;j&lt;len(people);j++&#123; if people[0][0] &gt;=people[j][0]&#123; people[j][1] --; &#125; &#125; people = people[1:] &#125; for i :=1;i&lt;len(res);i++ &#123; count :=0 for j :=0;j&lt;i;j++ &#123; if res[i][0] &lt;= res[j][0]&#123; count ++; &#125; &#125; res[i][1] = count &#125; return res;&#125; 407. Trapping Rain Water II下面的做法超时了。正解网上找了一个。11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495func dfs(heightMap [][]int, x,y int)&#123; if x &lt; 0 || x &gt;= len(heightMap) || y &lt;0 || y &gt;= len(heightMap[0])&#123; return &#125; if heightMap[x][y] != 0&#123; return &#125; heightMap[x][y] = 65535 dfs(heightMap,x+1,y) dfs(heightMap,x-1,y) dfs(heightMap,x,y+1) dfs(heightMap,x,y-1)&#125;func getArea(heightMap [][]int) int&#123; for i:=0;i&lt;len(heightMap[0]);i++&#123; dfs(heightMap,0,i) dfs(heightMap,len(heightMap)-1,i) &#125; for i:=0;i&lt;len(heightMap);i++&#123; dfs(heightMap,i,0) dfs(heightMap,i,len(heightMap[0])-1) &#125; count :=0 for i :=0;i&lt;len(heightMap);i++&#123; for j:=0;j&lt;len(heightMap[0]);j++&#123; if heightMap[i][j] == 0&#123; count ++ &#125;else if heightMap[i][j] ==65535&#123; heightMap[i][j] = 0; &#125; &#125; &#125; return count&#125;/*func getMin(heightMap [][]int) int&#123; min := 65535 m,n := len(heightMap),len(heightMap[0]) for i:=1;i&lt;m-1;i++&#123; for j:=1;j&lt;n-1;j++&#123; if heightMap[i][j] == 0&#123; continue; &#125; if min &gt; heightMap[i][j]&#123; min = heightMap[i][j] &#125; &#125; &#125; return min&#125;*/func getMin2(heightMap [][]int) int&#123; min := 65535 m,n := len(heightMap),len(heightMap[0]) for i:=0;i&lt;m;i++&#123; for j:=0;j&lt;n;j++&#123; if heightMap[i][j] == 0&#123; continue; &#125; if min &gt; heightMap[i][j]&#123; min = heightMap[i][j] &#125; &#125; &#125; return min&#125;func trapRainWater(heightMap [][]int) int &#123; res ,tmp:= 0,1 if len(heightMap) == 0 || len(heightMap[0]) == 0&#123; return 0 &#125; for true&#123; m,n := len(heightMap),len(heightMap[0]) min := getMin2(heightMap) for i:=0;i&lt;m;i++&#123; for j:=0;j&lt;n;j++&#123; if heightMap[i][j] &lt; min&#123; heightMap[i][j] = 0 continue; &#125; heightMap[i][j] -= min &#125; &#125; min = getMin2(heightMap) if min == 65535&#123; break &#125; tmp = min* getArea(heightMap) res += tmp &#125; return res&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 5 第五周周赛","date":"2016-09-18T10:10:18.000Z","path":"2016/09/18/leetcode_weekly_contest5/","text":"第一题: 400. Nth Digit这道题用暴力的直接写出从1到n的所有数字组合而成的字符串会超时。一种解法是：先计算出第n个字符是属于哪个数字的。边计算边统计之前的字符个数total。然后得到这个数字后，将这个数字转为字符串，并取n-total-1这个下标的字符，就是所求。123456789101112131415161718func findNthDigit(n int) int &#123; i := 0 mark, l := 1, 0 total := 0 for i = 1; total &lt; n; i++ &#123; if i &gt;= mark &#123; total += l + 1 l++ mark *= 10 &#125; else &#123; total += l &#125; &#125; i-- total -= l t := strconv.Itoa(i) return int(t[n-total-1] - '0')&#125; 第二题：401. Binary Watch没过，应该是题目有问题。题目中说顺序无所谓但是实际上顺序貌似还是有关系的。用二进制来进行计算。先递归的计算出所有可能的num情况。然后将对应的num读为时间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142var b = []int&#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512&#125;var ret []stringfunc readTime(num int) &#123; str := \"\" t := num &gt;&gt; 6 if t &gt;= 12 &#123; return &#125; str += strconv.Itoa(t) + \":\" t = num &amp; 63 if t &gt;= 60 &#123; return &#125; if t &lt; 10 &#123; str += \"0\" + strconv.Itoa(t) &#125; else &#123; str += strconv.Itoa(t) &#125; ret = append(ret, str)&#125;func help(now, num, idx int) &#123; if num == 0 &#123; readTime(now) return &#125; if idx &gt;= 10 &#123; return &#125; help(now, num, idx+1) help(now|b[idx], num-1, idx+1)&#125;func readBinaryWatch(num int) []string &#123; ret = []string&#123;&#125; if num == 0 &#123; return []string&#123;\"0:00\"&#125; &#125; for i := 0; i &lt; len(b); i++ &#123; help(b[i], num-1, i+1) &#125; return ret&#125; 第三题：402. Remove K Digits在裁剪的过程中，如果要裁剪掉k个字符，那么在一个字符串中，前k+1一个字符中一定会有至少一个字符被保留下来。所以算法的目的就是递归的找到这个字符，并对这个字符之后的字符串继续进行裁剪，直到得到最后的结果。另外，题目中要求不能有0，所以在得到结果之后还要去掉首部的0。1234567891011121314151617181920212223242526272829303132333435var res stringfunc help(num string, k int) &#123; if k &lt;= 0&#123; res = res + num return &#125; if k &gt;= len(num)&#123; return ; &#125; minIdx := 0 for i:=1;i&lt;=k;i++&#123; if num[i] &lt; num[minIdx]&#123; minIdx = i &#125; &#125; res = res + string(num[minIdx]) new := num[minIdx+1:] help(new,k - minIdx)&#125;func removeKdigits(num string, k int) string &#123; res = \"\" help(num,k) i:=0 for i=0;i&lt;len(res)&amp;&amp;res[i]=='0';i++&#123; &#125; if i&lt;len(res)&#123; res = res[i:] &#125;else&#123; res = \"0\" &#125; return res&#125; 第四题：403. Frog Jump很明显的递归的例子。用一个映射来讲stones[下标]距离 改成 map[距离]下标.然后从0开始起跳。距离为1。每一次进行判断，首先是是不是最后一个石头了，是则返回true。程序over。然后判断判断下目前所在的石头是哪一个。（检索map[stone[idx]+stp]即可知道，为0即不存在，返回false。）接下来就是继续进行跳跃，分别尝试跳跃stp,stp+1,stp-1的距离即可。需要注意stp==0的时候是没有意义的，直接返回false.1234567891011121314151617181920212223var m map[int]intfunc help(stones []int, idx int, stp int) bool &#123; if stp == 0 &#123; return false &#125; if idx == len(stones)-1 &#123; return true &#125; if m[stones[idx]+stp] == 0 &#123; return false &#125; idx = m[stones[idx]+stp] return help(stones, idx, stp-1) || help(stones, idx, stp+1) || help(stones, idx, stp)&#125;func canCross(stones []int) bool &#123; m = make(map[int]int) for i := 0; i &lt; len(stones); i++ &#123; m[stones[i]] = i &#125; return help(stones, 0, 1)&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"LeetCode Weekly Contest 4 第四周周赛","date":"2016-09-12T04:10:18.000Z","path":"2016/09/12/leetcode_weekly_contest4/","text":"用golang做了1，2，4题，第3题golang总是有问题换成c++来做。代码地址：leetcode solution(golang) ###396. Rotate Function###最暴力的方法莫过于一遍一遍计算。可以得到结果。第二种方法就是利用了前一次的结果。假设数组为[a,b,c,d]那么第一次计算的结果就是：0*a + 1*b + 2*c + 3*d第二次计算的结果是（从右往左旋转）：1*a + 2*b + 3*c + 0*d和之前的结果比：差值为：1*a+1*a+1*a-3*d == 1*a+1*a+1*a+1*d - 3*d所以基于前一次的结果f,可以得到下一次的结果的计算公式：t :=f+sum - A[len(A)-i]*len(A) 12345678910111213141516func maxRotateFunction(A []int) int &#123; sum,f:= 0,0 for i:=0;i&lt;len(A);i++&#123; sum += A[i] f += i*A[i] &#125; m := f for i:=1;i&lt;len(A);i++&#123; t :=f+sum - A[len(A)-i]*len(A) if m &lt; t&#123; m = t &#125; f += sum - A[len(A)-i]*len(A) &#125; return m&#125; ###397. Integer Replacement###很简单的递归计算题目。不过这么做复杂度比较高，能过也说明Leetcode的test case 有点简单了。123456789101112131415func integerReplacement(n int) int &#123; if n &lt;= 1&#123; return 0 &#125; if n %2 == 0&#123; return integerReplacement(n/2)+1 &#125;else&#123; t1,t2 := integerReplacement(n+1),integerReplacement(n-1) if t1 &lt;t2&#123; return t1 +1 &#125;else&#123; return t2 +1 &#125; &#125;&#125; ###398. Random Pick Index###这道题的解法，第一种是创建一个hash表map&lt;int,vector&lt;int&gt;&gt;来保存对应的映射关系。在初始化的时候建表。时间复杂度和空间复杂度都是o(n).在检索的时候直接查表取随机值，时间复杂度为o(1).不过最后会出现MLE错误。原因是leetcode这道题考察的点不是hash表，于是将内存限制为o(1).123456789101112131415161718192021222324//MLE代码class Solution &#123;private: unordered_map&lt;int, vector&lt;int&gt;&gt; m;public: Solution(vector&lt;int&gt; nums) &#123; srand(time(0)); for (int i = 0; i&lt;nums.size(); i++)&#123; if (m.count(nums[i]) == 0)&#123; vector&lt;int&gt; t; t.push_back(i); m[nums[i]] = t; &#125; else&#123; m[nums[i]].push_back(i); &#125; &#125; &#125; int pick(int target) &#123; int r = rand() % m[target].size(); return m[target][r]; &#125;&#125;; 这道题实际上考察的是蓄水池抽样，具体的可以看看这篇Blog。利用蓄水池抽样算法，就可以在不知道整个数组长度的情况下，就能保证各个元素获取的概率是相同的。不过貌似不用蓄水池抽样的方法也能通过。12345678910111213141516171819202122class Solution &#123; vector&lt;int&gt; num;public: Solution(vector&lt;int&gt; nums) &#123; num = nums; &#125; int pick(int target) &#123; int index = -1; int count = 0; for (int i = 0; i &lt; num.size(); i++)&#123; if (num[i] == target)&#123; count++; int r = rand() % count + 1; if (r == count)&#123; index = i; &#125; &#125; &#125; return index; &#125;&#125;; 顺带吐槽下leetcode的Golang. 这道题让我意识到Golang不适合在leetcode下刷题用。碰到大数据的题目几乎都会挂，比如109题和239题。还得发邮件给support才能在后台改成通过。这道题的golang解法提示WA。但是错误的test case在本地运行是可以通过的。12345678910111213141516171819202122232425type Solution struct &#123; nums []int&#125;func Constructor(nums []int) Solution &#123; var s Solution s.nums = nums return s&#125;func (this *Solution) Pick(target int) int &#123; idx,count := -1,0 for i:=0;i&lt;len(this.nums);i++&#123; if this.nums[i] == target&#123; count ++ r := rand.Intn(count) + 1 if r== count&#123; idx = i &#125; &#125; &#125; return idx&#125; ###399. Evaluate Division###这种解法最后也能过也是DIAO.o(n*n)的复杂度。遍历两遍。第一遍遍历提供的数据，利用提供的数据计算出所有的两两可提供的结果。比如提供给你 a/b b/c能得到a/b b/a a/a /b/b a/c c/a这几个结果。用map记录这些元素。第二遍遍历第一遍所得到的map进行同样的操作，来二次推导得到的结果。之后的检索操作就是查表操作。没想到这样的方法也能过。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283func calcEquation(equations [][]string, values []float64, query [][]string) []float64 &#123; m := make(map[[2]string]float64) //tm := make(map[string]float64) for i:=0;i&lt;len(equations);i++&#123; a,b :=equations[i][0],equations[i][1] m[[2]string&#123;a,b&#125;] =values[i] m[[2]string&#123;b,a&#125;] = 1/values[i] m[[2]string&#123;a,a&#125;] =1.0 m[[2]string&#123;b,b&#125;] =1.0 for j :=i+1;j&lt;len(equations);j++&#123; //in here to construct the map c,d := equations[j][0],equations[j][1] if a!=c &amp;&amp;a!=d &amp;&amp; b!=c &amp;&amp; b!=d&#123; continue// can't get any new info &#125; if a == c &amp;&amp;b == d || a == d&amp;&amp; b == c&#123; continue// can't get any new info &#125; if a == c&#123; m[[2]string&#123;d,b&#125;] = values[i]/values[j] m[[2]string&#123;b,d&#125;] = values[j]/values[i] &#125; if a == d&#123; m[[2]string&#123;c,b&#125;] = values[i]*values[j] m[[2]string&#123;b,c&#125;] = 1/(values[i]*values[j]) &#125; if b == c&#123; m[[2]string&#123;a,d&#125;] = values[i]*values[j] m[[2]string&#123;d,a&#125;] = 1/(values[j]*values[i]) &#125; if b == d&#123; m[[2]string&#123;a,c&#125;] = values[i]/values[j] m[[2]string&#123;c,a&#125;] = values[j]/values[i] &#125; &#125; &#125; for k,v := range m&#123; a,b := k[0],k[1] m[[2]string&#123;a,b&#125;] =v m[[2]string&#123;b,a&#125;] = 1/v m[[2]string&#123;a,a&#125;] =1.0 m[[2]string&#123;b,b&#125;] =1.0 for k1,v1 := range m&#123; //in here to construct the map c,d := k1[0],k1[1] if a!=c &amp;&amp;a!=d &amp;&amp; b!=c &amp;&amp; b!=d&#123; continue// can't get any new info &#125; if a == c &amp;&amp;b == d || a == d&amp;&amp; b == c&#123; continue// can't get any new info &#125; if a == c&#123; m[[2]string&#123;d,b&#125;] = v/v1 m[[2]string&#123;b,d&#125;] = v1/v &#125; if a == d&#123; m[[2]string&#123;c,b&#125;] = v*v1 m[[2]string&#123;b,c&#125;] = 1/(v*v1) &#125; if b == c&#123; m[[2]string&#123;a,d&#125;] = v*v1 m[[2]string&#123;d,a&#125;] = 1/(v*v1) &#125; if b == d&#123; m[[2]string&#123;a,c&#125;] = v/v1 m[[2]string&#123;c,a&#125;] = v1/v &#125; &#125; &#125; tmp := [2]string&#123;\"\",\"\"&#125; var ret []float64 for i:=0;i&lt;len(query);i++&#123; tmp[0],tmp[1] = query[i][0],query[i][1] v, ok := m[tmp] if ok&#123; ret = append(ret,v) &#125;else&#123; ret = append(ret,-1.0) &#125; &#125; return ret&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nachtz.github.io/tags/Leetcode/"},{"name":"Golang","slug":"Golang","permalink":"https://nachtz.github.io/tags/Golang/"}]},{"title":"将DPDK移植到snort上的DAQ","date":"2016-08-06T10:16:34.000Z","path":"2016/08/06/dpdk_daq/","text":"DAQ 与Snort在snort-daq中，daq的控制流程是这样的。如上所述，Snort在初始化的时候载入了daq。这个时候snort的所调用的api是daq_load_modules。也就是说，这个时候在主线程没有启动网卡，初始化实例的操作。在初始化整个snort之后（载入配置，载入daq及其他各个模块等等）。snort就进入了分析的阶段了。这个阶段的主角是pig，或者说更本质的，是pig下的analyzer。Snort下面开n个pig线程。pig线程下面调用analyzer来进行包解析。包解析的过程中是在pig线程中多线程并行进行的。每一个analyzer下面都初始化一个daq instance并调用acquire进行抓包并分析。每一个daq instance下面都有一个或多个网卡来获取数据。因为目的主要是介绍daq，所以怎么解析就不提了。从上图和上面的介绍就可以看得出来，一个snort下面有多个daq instance并行运行。每一个daq instance都会进行初始化操作，占用系统资源，获取网卡，抓包，调用callback，之间相互独立。并且是单线程的。 DAQ与DPDK如上面所介绍的。DAQ在设计的时候是单线程的。在本身的实现的几个模块中（Netmap,pcap等等）完全没有涉及到多线程的事情。在snort中的调用也是单线程并行调用的，相互之间各不影响。而Inter的DPDK在多线程方面则有限制。它所初始化的EAL层只能初始化一次。一个程序中只能运行一个dpdk主程序。所以就没有办法在snort中使用多线程。因为如果在snort中使用了多线程。那么实际上每个线程都会去尝试初始化dpdk的EAL。那么就会出错，导致最后只有一个线程能够成功初始化并启动。所以如果要想实现一个支持snort多线程的daq。就需要修改daq中api的逻辑。在实现中，利用线程id来绑定网卡。在daq的content中加入了一个nic-threadid的映射表。然后每个网卡都有一个独立的instance存储原本在daq_content中的信息。然后在线程调用daq相关函数的时候，都会先利用threadid来进行检索这个instance进行操作。通过这个方法就能够将dpdk中的各个网卡独立运行。 Github地址daq_dpdk基于的是dpdk16.04, daq2.1.0,snort 3.0 a04.使用方法在项目主页中。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"},{"name":"Snort","slug":"Snort","permalink":"https://nachtz.github.io/tags/Snort/"}]},{"title":"dpdk_ring剥离（单线程版）","date":"2016-06-17T10:19:59.000Z","path":"2016/06/17/dpdk_ring/","text":"DPDK_RING 剥离(sc)dpdk中的ring结构的原理在官方的doc中有。详细的介绍了单线程和多线程下的ring的结构的实现。其中线程安全的ring的出入队中没有用到锁，这个结构是比较巧妙的。此外，和一般的ring设计相比，dpdk的ring中减少了比较的次数和减法的次数。考虑了很多性能方面的东西。目前就剥离了单线程版的。代码如下： daq_ring.h12345678910111213141516171819202122232425262728293031323334353637383940414243#ifndef DAQ_RING_H#define DAQ_RING_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//#include &lt;pthread.h&gt;typedef struct _daq_ring&#123; // pthread_mutex_t mutex; int size; int mask; int cons_head; int cons_tail; int prod_head; int prod_tail; void * ring[0];&#125;;typedef struct _daq_ring daq_ring;//create a ring which can contain size's objects.daq_ring * daq_ring_create(int num);//fre a ring.int daq_ring_free(daq_ring * r);//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r);//see whether a ring is full.int daq_ring_isFull(daq_ring * r);//see the number of objects in ring now.int daq_ring_count(daq_ring * r);//see the size of a ring.int daq_ring_getSize(daq_ring *r);//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r);//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc);//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc);#endif//end of daq_ring.h -daq_ring.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include \"daq_ring.h\"/*typedef struct _daq_ring&#123; pthread_mutex_t mutex; unsigned int size; void * head; void * tail; void * memhead;&#125;daq_ring;*/daq_ring * daq_ring_create(int num)&#123; daq_ring * r = NULL; if(num &lt;=0)return NULL; r = (daq_ring *)malloc(sizeof(daq_ring) + num*sizeof(void*)); if(r == NULL)&#123; return NULL; &#125; r-&gt;size = num; r-&gt;mask = num-1; r-&gt;prod_head = r-&gt;prod_tail = r-&gt;cons_head = r-&gt;cons_tail = 0; // pthread_mutex_init(&amp;r-&gt;mutex,NULL); return r;&#125;//fre a ring.int daq_ring_free(daq_ring * r)&#123; free(r);&#125;//see whether a ring is empty.int daq_ring_isEmpty(daq_ring * r)&#123; return r-&gt;cons_tail == r-&gt;prod_tail;&#125;//see whether a ring is full.int daq_ring_isFull(daq_ring * r)&#123; return (((r-&gt;cons_tail - r-&gt;prod_tail -1)&amp;r-&gt;mask)==0);&#125;//see the number of objects in ring now.int daq_ring_count(daq_ring * r)&#123; return ((r-&gt;prod_tail - r-&gt;cons_tail)&amp;r-&gt;mask);&#125;//see the size of a ring.int daq_ring_getSize(daq_ring *r)&#123; return r-&gt;size;&#125;//see the number of objects can be inputed into the ring now.int daq_ring_freeCount(daq_ring * r)&#123; return ((r-&gt;cons_tail - r-&gt;prod_tail - 1) &amp; r-&gt;mask);&#125;//enqueue objects into a ring.int daq_ring_enqueue(daq_ring * r, void * const *obj_table, int num,int mc)&#123; int prod_head = r-&gt;prod_head; int cons_tail = r-&gt;cons_tail; int prod_next = prod_head +1; int mask = r-&gt;mask; int i ; int free = mask + cons_tail -prod_head; if(num &gt;free)&#123; if(free == 0)return 0; num = free; &#125; prod_next = prod_head +num; r-&gt;prod_head = prod_next; &#123; const int size = r-&gt;size; int idx = prod_head &amp; mask; if(idx + num &lt; size)&#123; for (i = 0; i &lt; (num &amp; ((~(unsigned)0x3))); i+=4, idx+=4) &#123; r-&gt;ring[idx] = obj_table[i]; r-&gt;ring[idx+1] = obj_table[i+1]; r-&gt;ring[idx+2] = obj_table[i+2]; r-&gt;ring[idx+3] = obj_table[i+3]; &#125; switch (num &amp; 0x3) &#123; case 3: r-&gt;ring[idx++] = obj_table[i++]; case 2: r-&gt;ring[idx++] = obj_table[i++]; case 1: r-&gt;ring[idx++] = obj_table[i++]; &#125; &#125;else&#123; for (i =0;idx&lt;size;++i,++idx) r-&gt;ring[idx] = obj_table[i]; for(idx = 0;i&lt;num;++i,++idx) r-&gt;ring[idx] = obj_table[i]; &#125; &#125; r-&gt;prod_tail = prod_next; return num;&#125;//dequeue objects from a ring.int daq_ring_dequeue(daq_ring * r, void **obj_table, int num,int mc)&#123; int cons_head,prod_tail; int cons_next,entries; int i; int mask = r-&gt;mask; cons_head = r-&gt;cons_head; prod_tail = r-&gt;prod_tail; entries = prod_tail - cons_head; if(num &gt; entries)&#123; if(entries == 0)return 0; num = entries; &#125; cons_next = cons_head + num; r -&gt; cons_head = cons_next; &#123; int idx = cons_head &amp; mask; int size = r-&gt; size; if (idx + num &lt; size) &#123; for (i = 0; i &lt; (num &amp; (~(unsigned)0x3)); i+=4, idx+=4) &#123; obj_table[i] = r-&gt;ring[idx]; obj_table[i+1] = r-&gt;ring[idx+1]; obj_table[i+2] = r-&gt;ring[idx+2]; obj_table[i+3] = r-&gt;ring[idx+3]; &#125; switch (num &amp; 0x3) &#123; case 3: obj_table[i++] = r-&gt;ring[idx++]; case 2: obj_table[i++] = r-&gt;ring[idx++]; case 1: obj_table[i++] = r-&gt;ring[idx++]; &#125; &#125; else &#123; for (i = 0; idx &lt; size; i++, idx++) obj_table[i] = r-&gt;ring[idx]; for (idx = 0; i &lt; num; i++, idx++) obj_table[i] = r-&gt;ring[idx]; &#125; &#125; r-&gt;cons_tail = cons_next; return num;&#125;void daq_ring_stat(daq_ring * r)&#123; printf(\"***********************************************\\n\"); printf(\"Daq_ring's size is %d\\n\",daq_ring_getSize(r)); printf(\"Daq_ring's objects now is %d.\\n\",daq_ring_count(r)); printf(\"Daq_ring's free space is %d\\n\",daq_ring_freeCount(r)); printf(\"Daq_ring is %s now.\\n\",daq_ring_isEmpty(r)?\"empty\":\"not empty\"); printf(\"Daq_ring is %s now.\\n\",daq_ring_isFull(r)?\"full\":\"not full\"); printf(\"***********************************************\\n\");&#125;void print_ptr(daq_ring *r)&#123; printf(\"r-&gt;cons:%p %p\\n\", r-&gt;cons_head, r-&gt;cons_tail); printf(\"r-&gt;prod:%p %p\\n\",r-&gt;prod_head,r-&gt;prod_tail); printf(\"r-&gt;ring[0]:%p\\n\",&amp;r-&gt;ring[0]); &#125;int test1()&#123; char * str[] = &#123; \"t1\",\"t2\",\"t3\",\"t4\",\"t5\",\"t6\",\"t7\",\"t8\",\"t9\",\"t10\",\"t11\",\"t12\",\"t13\" &#125;; void * ctx[12]; int i; for(i =0;i&lt;10;++i) printf(\"%s\\n\",str[i]); daq_ring * r = daq_ring_create(9); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(int i =0;i&lt;8;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r);print_ptr(r); daq_ring_enqueue(r,str,8,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,8,1); for(i =0;i&lt;10;++i) printf(\"%s\\n\",(char *)ctx[i]); return 0;&#125;int test2()&#123; int i; char * str[] = &#123; \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\", \"t7\", \"t8\", \"t9\", \"t10\", \"t11\", \"t12\", \"t13\", \"t14\", \"t15\", \"t16\", \"t17\" &#125;; void * ctx[18]; daq_ring * r = daq_ring_create(16); daq_ring_enqueue(r,str,14,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,4,1); for(i =0;i&lt;4;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r); daq_ring_enqueue(r,&amp;str[5],5,1); daq_ring_stat(r); print_ptr(r); daq_ring_dequeue(r,ctx,15,1); for(i =0;i&lt;15;++i) printf(\"%s\\n\",(char *)ctx[i]); daq_ring_stat(r); print_ptr(r);&#125;int main()&#123; test2(); return 0;&#125;","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]},{"title":"DPDK杂记","date":"2016-06-17T10:19:02.000Z","path":"2016/06/17/dpdk_note/","text":"DPDK编译动态库将common_linuxapp中的CONFIG_RTE_BUILD_SHARED_LIB和CONFIG_RTE_BUILD_COMBINE_LIBS都改为y，重新编译。将生成的lib文件拷贝到linux的lib中。（在dpdk16.04中，combine这个选项被取消了。邮件组中提到说是默认就是combine了。但是实际编译中发现不同的网卡驱动还是没有编译在一起。拷贝的时候都需要拷贝过去。）之后就是修改Makefile.将makefile中的1include $(RTE_SDK)/mk/rteextapp.mk 改为1include $(RTE_SDK)/mk/rte.extshared.mk 把binary name中的app改为1SHARED = yourname.so 最后再加上库：1LDLIBS += -L/home/nachtz/dpdk-2.2.0/x86_64-native-linuxapp-gcc/lib -ldpdk -lrt -lm -lgcc_s -ldl 就行了。","tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://nachtz.github.io/tags/DPDK/"}]}]